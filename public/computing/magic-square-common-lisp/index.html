<!DOCTYPE html>
<html><head lang="en"><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>Solving the Magic Square in Common Lisp - Aatmun Baxi</title><meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="description" content="Table of Contents The Problem Helper Functions Summing List Values Converting Between Grids and Flat Lists Grabbing Diagonals Checking Win Conditions Range Generation Pretty Printing The Solver Using the Solver The Problem The magic square problem is a typical recursion exercise given to students learning programming. Since I’ve been playing around with common lisp recently, I thought I’d use it as an excuse to learn a bit about the language." />
	<meta property="og:image" content=""/>
	<meta property="og:url" content="http://localhost:1313/computing/magic-square-common-lisp/">
  <meta property="og:site_name" content="Aatmun Baxi">
  <meta property="og:title" content="Solving the Magic Square in Common Lisp">
  <meta property="og:description" content="Table of Contents The Problem Helper Functions Summing List Values Converting Between Grids and Flat Lists Grabbing Diagonals Checking Win Conditions Range Generation Pretty Printing The Solver Using the Solver The Problem The magic square problem is a typical recursion exercise given to students learning programming. Since I’ve been playing around with common lisp recently, I thought I’d use it as an excuse to learn a bit about the language.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="computing">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Solving the Magic Square in Common Lisp">
  <meta name="twitter:description" content="Table of Contents The Problem Helper Functions Summing List Values Converting Between Grids and Flat Lists Grabbing Diagonals Checking Win Conditions Range Generation Pretty Printing The Solver Using the Solver The Problem The magic square problem is a typical recursion exercise given to students learning programming. Since I’ve been playing around with common lisp recently, I thought I’d use it as an excuse to learn a bit about the language.">

	
        <link href="http://localhost:1313/css/fonts.2c2227b81b1970a03e760aa2e6121cd01f87c88586803cbb282aa224720a765f.css" rel="stylesheet">
	

	
	<link rel="stylesheet" type="text/css" media="screen" href="http://localhost:1313/css/main.ac08a4c9714baa859217f92f051deb58df2938ec352b506df655005dcaf98cc0.css" />

	
	
		<script type="text/javascript"
		src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
		</script>
	
		
		<script type="text/x-mathjax-config">
		MathJax.Hub.Config({
			tex2jax: {
				inlineMath: [['$','$'], ['\\(','\\)']],
				displayMath: [['$$','$$'], ['\[','\]']],
				processEscapes: true,
				processEnvironments: true,
				skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
				TeX: { equationNumbers: { autoNumber: "AMS" },
						 extensions: ["AMSmath.js", "AMSsymbols.js"] }
			}
		});
		</script>
	

	
	
	
	
		
		
		<link rel="stylesheet" type="text/css" href="http://localhost:1313/css/modus_style.4717ee2590524fe42e9e105227b8cfdded2bf8ecb4290e25c9919fefce5f1a70.css">
		
</head>
<body>
        <div class="content"><header>
	<div class="main">
		<a href="http://localhost:1313/">Aatmun Baxi</a>
	</div>
	<nav>
		
		<a href="/comp/">Computing</a>
		
		<a href="/math/">Math</a>
		
		<a href="/misc/">Misc</a>
		
		<a href="/nihongo/">日本語コーナー</a>
		
		
	</nav>
</header>

<main>
	<article>
		<div class="title">
			<h1 class="title">Solving the Magic Square in Common Lisp</h1>
			<div class="meta">Posted on Jan 1, 0001</div>
		</div>
		

		<section class="body">
			<div class="ox-hugo-toc toc">
<div class="heading">Table of Contents</div>
<ul>
<li><a href="#the-problem">The Problem</a></li>
<li><a href="#helper-functions">Helper Functions</a>
<ul>
<li><a href="#summing-list-values">Summing List Values</a></li>
<li><a href="#converting-between-grids-and-flat-lists">Converting Between Grids and Flat Lists</a></li>
<li><a href="#grabbing-diagonals">Grabbing Diagonals</a></li>
<li><a href="#checking-win-conditions">Checking Win Conditions</a></li>
<li><a href="#range-generation">Range Generation</a></li>
<li><a href="#pretty-printing">Pretty Printing</a></li>
</ul>
</li>
<li><a href="#the-solver">The Solver</a></li>
<li><a href="#using-the-solver">Using the Solver</a></li>
</ul>
</div>
<!--endtoc-->
<h2 id="the-problem">The Problem</h2>
<p>The magic square problem is a typical recursion exercise given to students learning programming.
Since I’ve been playing around with common lisp recently, I thought I’d use it as an excuse to learn a bit about the language.</p>
<p>A magic square (of size 3) is a 3x3 grid of numbers whose rows, columns, and diagonals sum up to the same number.
We’ll be working with the simplest case here, where the grid can only be filled with values <code>1-9</code>, so the win condition is when the rows, columns, and diagonals sum up to <code>15</code>.
Our job is to write a program that takes as user input a grid of 9 numbers, possibly with some values filled out already, and return a solved magic square from those predetermined numbers.
If the square cannot be solved, we should return <code>nil</code>.</p>
<h2 id="helper-functions">Helper Functions</h2>
<p>We’ll model a 3x3 square as a flat list of 9 elements.
We index row-first.
For an example, the following table</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>1 2 3
</span></span><span style="display:flex;"><span>4 5 6
</span></span><span style="display:flex;"><span>7 8 9
</span></span></code></pre></div><p>will be encoded as the list <code>(1 2 3 4 5 6 7 8 9)</code>.</p>
<p>In order to check if a square is a “real” magic square, we need some helper functions that will be used to check the win condition.</p>
<h3 id="summing-list-values">Summing List Values</h3>
<p>The first thing we need is the ability to sum all values of a list.
This doesn’t really require much to do, but it’s convenient to have a succinct name to refer to.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lisp" data-lang="lisp"><span style="display:flex;"><span>(defun sum (vals)
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;Computes sum of values of a list&#34;</span>
</span></span><span style="display:flex;"><span>  (<span style="color:#a6e22e">apply</span> <span style="color:#a6e22e">#&#39;+</span> vals))
</span></span></code></pre></div><h3 id="converting-between-grids-and-flat-lists">Converting Between Grids and Flat Lists</h3>
<p>The next things we need is the ability to “flatten” a list that encodes a grid.
Internally, we’ll process everything as a 1 dimensional list, but we’d like to display and let the user work with the lists in a nicer human readable format as a 3x3 grid.
For this we’ll implement a function to convert the 2 dimensional grid into a 1 dimensional list.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lisp" data-lang="lisp"><span style="display:flex;"><span>(defun flatten (list-of-lists)
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;Flatten a list of lists (single nested level)&#34;</span>
</span></span><span style="display:flex;"><span>  (<span style="color:#a6e22e">apply</span> <span style="color:#a6e22e">#&#39;append</span> list-of-lists))
</span></span></code></pre></div><p>We’ve assumed strongly that the lists we use are length 9 and the grid we want is 3x3.
We might want to change this if we want a magic square solver for larger grids like 4x4 or 5x5.</p>
<p>We also implement a <code>transpose</code> function, whose use will become apparent soon.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lisp" data-lang="lisp"><span style="display:flex;"><span>(defun transpose (square)
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;Transposes a square&#34;</span>
</span></span><span style="display:flex;"><span>  (<span style="color:#a6e22e">apply</span> <span style="color:#a6e22e">#&#39;append</span> (loop for i <span style="color:#e6db74">:from</span> <span style="color:#ae81ff">0</span> <span style="color:#e6db74">:to</span> <span style="color:#ae81ff">2</span> <span style="color:#e6db74">:collect</span>
</span></span><span style="display:flex;"><span>                        (<span style="color:#a6e22e">apply</span> <span style="color:#a6e22e">#&#39;append</span> (loop for j <span style="color:#e6db74">:from</span> <span style="color:#ae81ff">0</span> <span style="color:#e6db74">:to</span> <span style="color:#ae81ff">2</span> <span style="color:#e6db74">:collect</span>
</span></span><span style="display:flex;"><span>                                              (<span style="color:#a6e22e">list</span> (<span style="color:#a6e22e">nth</span> (<span style="color:#a6e22e">+</span> i (<span style="color:#a6e22e">*</span> j <span style="color:#ae81ff">3</span>)) square)))))))
</span></span></code></pre></div><p>Note here that it should be trivial to extend these functions to work on arbitrarily-sized square by doing some logic on the bounds and hard-coded numbers within the function.
Not that you’d want to, there’s already 9! (9 factorial) permutations to check with just a 3x3 grid&hellip;</p>
<h3 id="grabbing-diagonals">Grabbing Diagonals</h3>
<p>We also implement two functions that get the main diagonal and off-diagonal of a grid from a flat list.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lisp" data-lang="lisp"><span style="display:flex;"><span>(defun main-diagonal (square)
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;Gets main diagonal of square&#34;</span>
</span></span><span style="display:flex;"><span>  (<span style="color:#a6e22e">list</span> (<span style="color:#a6e22e">nth</span> <span style="color:#ae81ff">0</span> square) (<span style="color:#a6e22e">nth</span> <span style="color:#ae81ff">4</span> square) (<span style="color:#a6e22e">nth</span> <span style="color:#ae81ff">8</span> square)))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(defun off-diagonal (square)
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;Gets off diagonal of square&#34;</span>
</span></span><span style="display:flex;"><span>  (<span style="color:#a6e22e">list</span> (<span style="color:#a6e22e">nth</span> <span style="color:#ae81ff">2</span> square) (<span style="color:#a6e22e">nth</span> <span style="color:#ae81ff">4</span> square) (<span style="color:#a6e22e">nth</span> <span style="color:#ae81ff">6</span> square)))
</span></span></code></pre></div><h3 id="checking-win-conditions">Checking Win Conditions</h3>
<p>Now that we have functions to get the rows, columns, and diagonals, we can go about checking win conditions.
The win conditions in the 3x3 case are that the sum of all rows, columns, and diagonals equal <code>15</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lisp" data-lang="lisp"><span style="display:flex;"><span>(defun filled? (square)
</span></span><span style="display:flex;"><span>  (<span style="color:#a6e22e">not</span> (<span style="color:#a6e22e">member</span> <span style="color:#ae81ff">0</span> square)))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(defun rows-solved? (square)
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;Checks if rows of square are solved&#34;</span>
</span></span><span style="display:flex;"><span>  (<span style="color:#66d9ef">let</span> ((solved (loop <span style="color:#e6db74">:for</span> i <span style="color:#e6db74">:from</span> <span style="color:#ae81ff">0</span> <span style="color:#e6db74">:below</span> <span style="color:#ae81ff">9</span> by <span style="color:#ae81ff">3</span> <span style="color:#e6db74">:collect</span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">;; Magic number here only applies for 3x3 squares...</span>
</span></span><span style="display:flex;"><span>                   (<span style="color:#a6e22e">eq</span> <span style="color:#ae81ff">15</span> (sum (<span style="color:#a6e22e">subseq</span> square i (<span style="color:#a6e22e">+</span> <span style="color:#ae81ff">3</span> i)))))))
</span></span><span style="display:flex;"><span>    (<span style="color:#a6e22e">every</span> (lambda (x) (<span style="color:#a6e22e">eq</span> x <span style="color:#66d9ef">t</span>)) solved)))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(defun columns-solved? (square)
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;Checks if the columns of square are solved&#34;</span>
</span></span><span style="display:flex;"><span>  (rows-solved? (transpose square)))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(defun diagonals-solved? (square)
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;Check if diagonals of square (flat list) are solved&#34;</span>
</span></span><span style="display:flex;"><span>  (and (<span style="color:#a6e22e">eq</span> <span style="color:#ae81ff">15</span> (sum (main-diagonal square))) (<span style="color:#a6e22e">eq</span> <span style="color:#ae81ff">15</span> (sum (off-diagonal square)))))
</span></span></code></pre></div><p>We can chain these together to form a final <code>solved?</code> function, which checks if a square is a magic square.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lisp" data-lang="lisp"><span style="display:flex;"><span>(defun solved? (square)
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;Determines if square is solved&#34;</span>
</span></span><span style="display:flex;"><span>  (and (rows-solved? square) (columns-solved? square) (diagonals-solved? square)))
</span></span></code></pre></div><h3 id="range-generation">Range Generation</h3>
<p>This neat little function emulates (to some extent) python’s <code>range</code> function.
It makes use of the <code>loop</code> macro, which is wonderfully flexible.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lisp" data-lang="lisp"><span style="display:flex;"><span>(defun range (<span style="color:#a6e22e">max</span> <span style="color:#66d9ef">&amp;key</span> (<span style="color:#a6e22e">min</span> <span style="color:#ae81ff">0</span>) (step <span style="color:#ae81ff">1</span>))
</span></span><span style="display:flex;"><span> <span style="color:#e6db74">&#34;Generates Python-like ranges&#34;</span>
</span></span><span style="display:flex;"><span>  (loop for n from <span style="color:#a6e22e">min</span> below <span style="color:#a6e22e">max</span> by step
</span></span><span style="display:flex;"><span>        collect n))
</span></span></code></pre></div><h3 id="pretty-printing">Pretty Printing</h3>
<p>Just to aid visually, we’ll write a function to print a flat list as a 3x3 grid.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lisp" data-lang="lisp"><span style="display:flex;"><span>(defun print-square (square)
</span></span><span style="display:flex;"><span>  (cond ((<span style="color:#a6e22e">null</span> square) (<span style="color:#a6e22e">print</span> <span style="color:#66d9ef">nil</span>))
</span></span><span style="display:flex;"><span>        (<span style="color:#66d9ef">t</span> (<span style="color:#a6e22e">format</span> <span style="color:#66d9ef">nil</span> <span style="color:#e6db74">&#34;~{~a ~a ~a~%~}&#34;</span> square))))
</span></span></code></pre></div><h2 id="the-solver">The Solver</h2>
<p>The solver function should take in a grid-formatted 3x3 square with possibly-filled in values, with <code>nil</code> indicating unfilled values.
The solver should return a solved magic square, or <code>nil</code> otherwise.</p>
<p>The top-level <code>solve</code> function will format the grid into a flat list and pass it to an internal function <code>solve--internal</code> which will employ recursion to solve the grid.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lisp" data-lang="lisp"><span style="display:flex;"><span>(defun solve (square)
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;Solves magic square from existing square&#34;</span>
</span></span><span style="display:flex;"><span>  (<span style="color:#66d9ef">let*</span> ((flat-square (<span style="color:#a6e22e">mapcar</span> (lambda (x) (<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">not</span> x) <span style="color:#ae81ff">0</span> x) ) (flatten square)))
</span></span><span style="display:flex;"><span>         (used (<span style="color:#a6e22e">remove</span> <span style="color:#ae81ff">0</span> (<span style="color:#a6e22e">remove-duplicates</span> flat-square)))
</span></span><span style="display:flex;"><span>         (solutions <span style="color:#66d9ef">nil</span>))
</span></span><span style="display:flex;"><span>    (solve--internal flat-square solutions <span style="color:#ae81ff">0</span> used)))
</span></span></code></pre></div><p>This function just maps <code>nil</code> to <code>0</code>, flattens the square, and initializes an internal solve, keeping track of the already-used values in the list.</p>
<p>The internal function looks like this</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lisp" data-lang="lisp"><span style="display:flex;"><span>(defun solve--internal (square solutions index used)
</span></span><span style="display:flex;"><span>  (cond
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">;; entry is filled and we aren&#39;t at the end</span>
</span></span><span style="display:flex;"><span>    ((and (<span style="color:#a6e22e">not</span> (filled? square)) (<span style="color:#a6e22e">not</span> (<span style="color:#a6e22e">eq</span> <span style="color:#ae81ff">0</span> (<span style="color:#a6e22e">nth</span> index square))))
</span></span><span style="display:flex;"><span>     (<span style="color:#66d9ef">return-from</span> solve--internal (solve--internal square solutions (<span style="color:#a6e22e">+</span> index <span style="color:#ae81ff">1</span>) used)))
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">;; at end with no solution</span>
</span></span><span style="display:flex;"><span>    ((and (filled? square) (<span style="color:#a6e22e">not</span> (solved? square)))
</span></span><span style="display:flex;"><span>     (<span style="color:#66d9ef">return-from</span> solve--internal <span style="color:#66d9ef">nil</span>))
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">;; at end with solution</span>
</span></span><span style="display:flex;"><span>    ((solved? square) (<span style="color:#66d9ef">return-from</span> solve--internal square))
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">;; unfilled otherwise</span>
</span></span><span style="display:flex;"><span>    ((<span style="color:#a6e22e">not</span> (filled? square))
</span></span><span style="display:flex;"><span>     (loop <span style="color:#e6db74">:for</span> num <span style="color:#e6db74">:in</span> (range <span style="color:#ae81ff">10</span> <span style="color:#e6db74">:min</span> <span style="color:#ae81ff">1</span>) <span style="color:#e6db74">:when</span> (<span style="color:#a6e22e">not</span> (<span style="color:#a6e22e">member</span> num used))
</span></span><span style="display:flex;"><span>           do
</span></span><span style="display:flex;"><span>              (setf (<span style="color:#a6e22e">nth</span> index square) num)
</span></span><span style="display:flex;"><span>              (push num used)
</span></span><span style="display:flex;"><span>              (<span style="color:#66d9ef">let*</span> ((possible-sol (solve--internal square solutions (<span style="color:#a6e22e">+</span> index <span style="color:#ae81ff">1</span>) used)))
</span></span><span style="display:flex;"><span>                (<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">not</span> (<span style="color:#a6e22e">null</span> possible-sol))
</span></span><span style="display:flex;"><span>                    (<span style="color:#66d9ef">return-from</span> solve--internal possible-sol)
</span></span><span style="display:flex;"><span>                    (<span style="color:#66d9ef">progn</span> (setf (<span style="color:#a6e22e">nth</span> index square) <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>                           (setf used (<span style="color:#a6e22e">remove</span> num used))))))
</span></span><span style="display:flex;"><span>     (<span style="color:#66d9ef">return-from</span> solve--internal solutions))))
</span></span></code></pre></div><h2 id="using-the-solver">Using the Solver</h2>
<p>We can now solve some magic squares.</p>
<p>Let’s solve a blank one first.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lisp" data-lang="lisp"><span style="display:flex;"><span>(defvar solution (solve (<span style="color:#a6e22e">list</span> (<span style="color:#a6e22e">list</span> <span style="color:#66d9ef">nil</span> <span style="color:#66d9ef">nil</span> <span style="color:#66d9ef">nil</span>) (<span style="color:#a6e22e">list</span> <span style="color:#66d9ef">nil</span> <span style="color:#66d9ef">nil</span> <span style="color:#66d9ef">nil</span>) (<span style="color:#a6e22e">list</span> <span style="color:#66d9ef">nil</span> <span style="color:#66d9ef">nil</span> <span style="color:#66d9ef">nil</span>))))
</span></span><span style="display:flex;"><span>(print-square solution)
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>2 7 6
</span></span><span style="display:flex;"><span>9 5 1
</span></span><span style="display:flex;"><span>4 3 8
</span></span></code></pre></div><p>Note the function only returns the first square that it finds to be solved.</p>
<p>We can also solve squares with pre-filled values and check if a solution is possible.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lisp" data-lang="lisp"><span style="display:flex;"><span>(print-square (solve (<span style="color:#a6e22e">list</span> (<span style="color:#a6e22e">list</span> <span style="color:#66d9ef">nil</span> <span style="color:#66d9ef">nil</span> <span style="color:#ae81ff">4</span>) (<span style="color:#a6e22e">list</span> <span style="color:#66d9ef">nil</span> <span style="color:#66d9ef">nil</span> <span style="color:#66d9ef">nil</span>) (<span style="color:#a6e22e">list</span> <span style="color:#66d9ef">nil</span> <span style="color:#66d9ef">nil</span> <span style="color:#66d9ef">nil</span>))))
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>2 9 4
</span></span><span style="display:flex;"><span>7 5 3
</span></span><span style="display:flex;"><span>6 1 8
</span></span></code></pre></div><p>Of course, there are also situations where a solution is not possible given pre-filled entries.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lisp" data-lang="lisp"><span style="display:flex;"><span>(print-square (solve (<span style="color:#a6e22e">list</span> (<span style="color:#a6e22e">list</span> <span style="color:#ae81ff">9</span> <span style="color:#66d9ef">nil</span> <span style="color:#ae81ff">4</span>) (<span style="color:#a6e22e">list</span> <span style="color:#66d9ef">nil</span> <span style="color:#66d9ef">nil</span> <span style="color:#66d9ef">nil</span>) (<span style="color:#a6e22e">list</span> <span style="color:#66d9ef">nil</span> <span style="color:#66d9ef">nil</span> <span style="color:#66d9ef">nil</span>))))
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>NIL
</span></span></code></pre></div><p>Notice that any valid magic square also has its transpose as a valid magic square.
We can verify that our solver works by checking if we get a result by taking the transpose.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lisp" data-lang="lisp"><span style="display:flex;"><span>(print-square (solve (<span style="color:#a6e22e">list</span> (<span style="color:#a6e22e">list</span> <span style="color:#66d9ef">nil</span> <span style="color:#66d9ef">nil</span> <span style="color:#66d9ef">nil</span>) (<span style="color:#a6e22e">list</span> <span style="color:#66d9ef">nil</span> <span style="color:#66d9ef">nil</span> <span style="color:#66d9ef">nil</span>) (<span style="color:#a6e22e">list</span> <span style="color:#ae81ff">4</span> <span style="color:#66d9ef">nil</span> <span style="color:#66d9ef">nil</span>))))
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>2 7 6
</span></span><span style="display:flex;"><span>9 5 1
</span></span><span style="display:flex;"><span>4 3 8
</span></span></code></pre></div>
		</section>

		<div class="post-tags">
			
			
			<nav class="nav tags">
				<ul class="tags">
					
					<li><a href="/tags/lisp">lisp</a></li>
					
					<li><a href="/tags/programming">programming</a></li>
					
				</ul>
			</nav>
			
			
		</div>
		</article>
</main>
<footer>
  <div style="display:flex"></div>
  <div class="footer-info">
    2024  <a
      href="https://github.com/athul/archie">Archie Theme</a> | Built with <a href="https://gohugo.io">Hugo</a>
  </div>
</footer>
</div>
    </body>
</html>
