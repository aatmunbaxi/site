#+hugo_base_dir: /home/aatmun/websites/site/
#+hugo_weight: auto
#+bibliography: ~/Documents/bib/reference-articles.bib
#+options: ':t todo:nil date:t
#+cite_export: csl
#+startup: logdone


* Home
:PROPERTIES:
:EXPORT_HUGO_FRONT_MATTER: :toc false :author false
:EXPORT_FILE_NAME: _index
:EXPORT_HUGO_WEIGHT: -10
:END:
** About Me
:PROPERTIES:
:EXPORT_HUGO_SECTION:
:EXPORT_HUGO_MENU: :menu main
:END:
I am a PhD student in mathematics at Texas A&M University.

- *Advisor*: [[https://people.tamu.edu/~rowell/][Dr. Eric Rowell]]
- *Research interests:* Braided fusion categories
*** Education
- PhD Mathematics, Texas A&M University (in progress)
- MS Mathematics, Texas A&M University 2023
- BS Mathematics, UCLA 2021
*** Hobbies
- Programming. I'm currently working in Rust, Common Lisp, and Python.
- Liverpool FC
- Astrophotography. Check my images [[*Astrophotos][here]]
- Learning japanese through immersion
- Free (as in freedom) software
  - This site is deployed with the [[https://github.com/kaushalmodi/ox-hugo][ox-hugo]] program in GNU emacs
** [[https://aatmunbaxi.github.io/crossed-braining][My Digital Garden]]
A smattering of my atomic notes and how they relate to each other.
If they don't seem to make sense to everyone, that's because they're not meant to.
After all, they're what I (claim to) know in my own words.
** Contact
- *Email*: [[mailto:abaxi@tamu.edu][abaxi@tamu.edu]]
- *Office*: Blocker 506B
* Math
:PROPERTIES:
:EXPORT_HUGO_SECTION: math
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :type post
:END:
** Math
:PROPERTIES:
:EXPORT_HUGO_SECTION: math
:EXPORT_FILE_NAME: _index
:EXPORT_HUGO_MENU: :menu main
:END:
Here I keep some thoughts about math-related things I find interesting or worth sharing.
** DRAFT \( \operatorname{Rep}(G) \)-type Fusion Rules :categories:noexport:
:PROPERTIES:
:EXPORT_HUGO_SECTION: math
:EXPORT_FILE_NAME: repG_fusion_rules
:EXPORT_OPTIONS: toc:t
:END:
/Disclaimer: These results have not been subjected to the rigor of publication./

As a spiritual continuation of the last article about realizing fusion rules, we realize some more multiplicity-free fusion rules on the AnyonWiki.
This time, we realize fusion rules as the fusion rules of the category of finite-dimensional complex representations of finite groups.
It turns out that these are some of the simplest examples of fusion categories and thus have particularly nice properties which allow us to easily recognize them.

*** Dimension as a Proxy for Recognizing \( \operatorname{Rep}(G) \)
Recall that fusion categories have a notion of /dimension/ that is more general than the familiar concept of vector space dimension.
In particular, the dimension function in fusion categories "behaves like" the regular dimension function on vector spaces, satisfying \( \dim (X \otimes Y) = \dim X \dim Y \) and \( \dim (X \oplus Y) = \dim X + \dim Y \), while not being required to be an integer.
Remember in the last article, there were objects of dimension \( \sqrt[\phantom{a}]{N} \) for some square-free integer \( N \).
However, in categories like \( \operatorname{Rep}(G) \), things are simpler.

In the fusion category \( \operatorname{Rep}(G) \), the dimensions of the simple objects are precisely the dimensions of the underlying vector spaces of the irreducible representations.
What's more is, from [[https://en.wikipedia.org/wiki/Character_theory][character theory]], the sum of the squares of the dimensions of irreducible representations equals the order of the group \( G \).
But this sum is just the dimension of the category!
This gives us a complete description of which groups are candidates for realizing certain fusion rules.

*** Recognizing \( \operatorname{Rep}(G) \)-type Fusion Rules
The basic idea is now to look for /integral/ fusion rules--fusion rules in which all objects (and hence the fusion ring)--has dimension equal to an integer.
Going with the AnyonWiki, let's say these fusion rules are \( \operatorname{FR}^{-,-}_-\) .
If \( \operatorname{FR}^{-,-}_- \) has a \( \operatorname{Rep}(G) \)-categorification, then the group \( G \) must have order equal to the dimension of the fusion ring, which we'll denote \( N \).
Thus, we should look only at groups of order \( N \), which we can do with a computer algebra system such as =GAP=.

From there, we can list out all irreducible representations of such groups.
The rank of \( \operatorname{FR}^{-,-}_- \) should be equal to the number of irreducible representations of \( G \) if it has a \( \operatorname{Rep}(G) \)-categorification, so we can further filter out possible candidate groups by the number of irreducible representations they afford.

Once we have a list of groups with order \( \dim \operatorname{FR}^{-,-}_- \) and number of irreducible representations (irreps) equal to \( \operatorname{rank} \operatorname{FR}^{-,-}_- \), we must look at the fusion rules of the irreps.
The fusion rules are exactly as they sound, namely, if \( ( \rho_{i} , V_i ), (\rho_{j} , V_{j}) \) are two irreducible representations, then
\begin{equation}
\label{eq:1}
V_i \otimes  V_j = \bigoplus_{1 \leqslant k \leqslant \operatorname{rank} \operatorname{Rep}(G)}^{} m_k V_k
\end{equation}
for some non-negative integers \( m_k \).
To find these \( m_k \), character theory comes to the rescue.

Glossing over many details, to each representation of \( G \) we can associate a *character*.
The characters of the irreps are called *irreducible characters*.
The irreducible characters satisfy a relation called [[https://groupprops.subwiki.org/wiki/Character_orthogonality_theorem][character orthogonality]], which makes it a near-trivial computational task to find the multiplicity \( m_k \).
i.e. to find \( m_k \) in the decomposition of \( V_i \otimes V_j \), one need only compute \( \left\langle \chi_i \chi_j , \chi_k \right\rangle \).
Once again, this can all be done quickly with the help of a computer algebra system.

As a final step, we have to resolve some labelling ambiguities used on the AnyonWiki vs the output of such a computer algebra system.
*** Realizing Unrecognized Fusion Rules
Implementing the above strategy, we get the following realizations.

**** \( \operatorname{FR}^{8,2}_5 \) as \( \operatorname{Rep}(\operatorname{Dic}(5)) \)
#+name: 20-1_fusion_table
#+caption: Fusion table for =SmallGroup= ID =[20,1]=
| 1 | 2 | 3 | 4 |         5 |         6 |         7 |         8 |
| 2 | 1 | 4 | 3 |         5 |         6 |         7 |         8 |
| 3 | 4 | 2 | 1 |         6 |         5 |         8 |         7 |
| 4 | 3 | 1 | 2 |         6 |         5 |         8 |         7 |
| 5 | 5 | 6 | 6 | 1 + 2 + 7 | 3 + 4 + 8 |     5 + 7 |     6 + 8 |
| 6 | 6 | 5 | 5 | 3 + 4 + 8 | 1 + 2 + 7 |     6 + 8 |     5 + 7 |
| 7 | 7 | 8 | 8 |     5 + 7 |     6 + 8 | 1 + 2 + 5 | 3 + 4 + 6 |
| 8 | 8 | 7 | 7 |     6 + 8 |     5 + 7 | 3 + 4 + 6 | 1 + 2 + 5 |

The objects have the correspondence with the AnyonWiki (AW):
#+caption: Label mapping for \( \operatorname{Rep}(\operatorname{Dic}(5)) \) against \( \operatorname{FR}^{8,2}_5 \).
| GAP Irrep Index | AW Label |
|-----------------+----------|
|               1 |        1 |
|               2 |        2 |
|               3 |        3 |
|               4 |        4 |
|               5 |        7 |
|               6 |        6 |
|               7 |        5 |
|               8 |        8 |

**** \( \operatorname{FR}^{9,0}_{22} \) is \( \operatorname{Rep}((S_3 \times S_3)\rtimes \mathbf{Z}_2) \)
The fusion rules straight out of GAP are in Table ref:72-40_fusion_rules.
No object labelling needs to be changed to match that of \( \operatorname{FR}^{9,0}_{22} \).
#+name: 72-40_fusion_rules
#+caption: Rep(G) fusion rules for group with GAP ID =[72,40]=.
| 1 | 2 | 3 | 4 | 5             | 6                     | 7                     | 8                     | 9                     |
| 2 | 1 | 4 | 3 | 5             | 9                     | 8                     | 7                     | 6                     |
| 3 | 4 | 1 | 2 | 5             | 9                     | 7                     | 8                     | 6                     |
| 4 | 3 | 2 | 1 | 5             | 6                     | 8                     | 7                     | 9                     |
| 5 | 5 | 5 | 5 | 1 + 2 + 3 + 4 | 6 + 9                 | 7 + 8                 | 7 + 8                 | 6 + 9                 |
| 6 | 9 | 9 | 6 | 6 + 9         | 1 + 4 + 5 + 7 + 8 + 9 | 6 + 7 + 8 + 9         | 6 + 7 + 8 + 9         | 2 + 3 + 5 + 6 + 7 + 8 |
| 7 | 8 | 7 | 8 | 7 + 8         | 6 + 7 + 8 + 9         | 1 + 3 + 5 + 6 + 8 + 9 | 2 + 4 + 5 + 6 + 7 + 9 | 6 + 7 + 8 + 9         |
| 8 | 7 | 8 | 7 | 7 + 8         | 6 + 7 + 8 + 9         | 2 + 4 + 5 + 6 + 7 + 9 | 1 + 3 + 5 + 6 + 8 + 9 | 6 + 7 + 8 + 9         |
| 9 | 6 | 6 | 9 | 6 + 9         | 2 + 3 + 5 + 6 + 7 + 8 | 6 + 7 + 8 + 9         | 6 + 7 + 8 + 9         | 1 + 4 + 5 + 7 + 8 + 9 |

**** \( \operatorname{FR}^{9,2}_8 \) is \( \operatorname{Rep}((\mathbf{Z}_6 \times \mathbf{Z}_2)\rtimes \mathbf{Z}_2) \)
#+caption: \( \operatorname{Rep}(G) \) for \( G \) the group with GAP ID =[24,8]=
#+name: 24-8_fusion_rules
| 1 | 2 | 3 | 4 | 5         | 6         | 7             | 8         | 9         |
| 2 | 1 | 4 | 3 | 6         | 5         | 7             | 9         | 8         |
| 3 | 4 | 1 | 2 | 5         | 6         | 7             | 8         | 9         |
| 4 | 3 | 2 | 1 | 6         | 5         | 7             | 9         | 8         |
| 5 | 6 | 5 | 6 | 1 + 3 + 6 | 2 + 4 + 5 | 8 + 9         | 7 + 8     | 7 + 9     |
| 6 | 5 | 6 | 5 | 2 + 4 + 5 | 1 + 3 + 6 | 8 + 9         | 7 + 9     | 7 + 8     |
| 7 | 7 | 7 | 7 | 8 + 9     | 8 + 9     | 1 + 2 + 3 + 4 | 5 + 6     | 5 + 6     |
| 8 | 9 | 8 | 9 | 7 + 8     | 7 + 9     | 5 + 6         | 2 + 4 + 6 | 1 + 3 + 5 |
| 9 | 8 | 9 | 8 | 7 + 9     | 7 + 8     | 5 + 6         | 1 + 3 + 5 | 2 + 4 + 6 |


#+caption: Label mapping for \(\operatorname{Rep}((\mathbf{Z}_6 \times \mathbf{Z}_2)) \rtimes \mathbf{Z}_2\) against \( \operatorname{FR}^{9,2}_8 \).
| =i= in =FusionTable(G)[i]= | AW Object Label |
|------------------------+-----------------|
|                      1 |               1 |
|                      2 |               2 |
|                      3 |               4 |
|                      4 |               3 |
|                      5 |               7 |
|                      6 |               6 |
|                      7 |               5 |
|                      8 |               8 |
|                      9 |               9 |

*** Alternative Realizations of Currently Recognized Fusion Rules
Along the way, \( \operatorname{Rep}(G) \)-type categories also provided alternative ways to realize fusion rules on the AnyonWiki that were already categorified.
In mathematical terms, this would mean we have found a Grothendieck equivalent fusion category.
**** \( \operatorname{Adj}(\operatorname{SO}(11)_2) \) is also \( \operatorname{Rep}(D_{11}) \)
#+caption: Fusion Table for \( \operatorname{Rep}(D_{11}) \)
| 1 | 2 | 3         | 4         | 5         | 6         | 7         |
| 2 | 1 | 3         | 4         | 5         | 6         | 7         |
| 3 | 3 | 1 + 2 + 4 | 3 + 5     | 4 + 6     | 5 + 7     | 6 + 7     |
| 4 | 4 | 3 + 5     | 1 + 2 + 6 | 3 + 7     | 4 + 7     | 5 + 6     |
| 5 | 5 | 4 + 6     | 3 + 7     | 1 + 2 + 7 | 3 + 6     | 4 + 5     |
| 6 | 6 | 5 + 7     | 4 + 7     | 3 + 6     | 1 + 2 + 5 | 3 + 4     |
| 7 | 7 | 6 + 7     | 5 + 6     | 4 + 5     | 3 + 4     | 1 + 2 + 3 |
**** \(\operatorname{Adj}(\operatorname{SO}(16)_2)\) is also \( \operatorname{Rep}(\operatorname{Dic}_4) \)


#+caption: Fusion Rules for \( \operatorname{Rep}(Q_{16}) \)
| 1 | 2 | 3 | 4 |             5 |         6 |         7 |
| 2 | 1 | 4 | 3 |             5 |         7 |         6 |
| 3 | 4 | 1 | 2 |             5 |         7 |         6 |
| 4 | 3 | 2 | 1 |             5 |         6 |         7 |
| 5 | 5 | 5 | 5 | 1 + 2 + 3 + 4 |     6 + 7 |     6 + 7 |
| 6 | 7 | 7 | 6 |         6 + 7 | 1 + 4 + 5 | 2 + 3 + 5 |
| 7 | 6 | 6 | 7 |         6 + 7 | 2 + 3 + 5 | 1 + 4 + 5 |

Looks the same as \( \operatorname{Adj}(\operatorname{SO}(16)_2) \).

**** \( \operatorname{FR}^{7,2}_4 \) is also \( \operatorname{Rep}(QD_{16}) \)
This group is called the /quasi-dicyclic group/ of order 16.
#+caption: Fusion rules for \( \operatorname{Rep}(QD_{16}) \)
| 1 | 2 | 3 | 4 |             5 |         6 |         7 |
| 2 | 1 | 4 | 3 |             5 |         7 |         6 |
| 3 | 4 | 1 | 2 |             5 |         7 |         6 |
| 4 | 3 | 2 | 1 |             5 |         6 |         7 |
| 5 | 5 | 5 | 5 | 1 + 2 + 3 + 4 |     6 + 7 |     6 + 7 |
| 6 | 7 | 7 | 6 |         6 + 7 | 2 + 3 + 5 | 1 + 4 + 5 |
| 7 | 6 | 6 | 7 |         6 + 7 | 1 + 4 + 5 | 2 + 3 + 5 |

Technically, this fusion rule has not been realized yet, but it can be realized as a zesting of \( \operatorname{FR}^{7,0}_1 : \operatorname{Adj}(\operatorname{SO}(16)_2) \)

**** \( \operatorname{FR}^{8,0}_3 \) is also \( \operatorname{Rep}(D_{10}) \)
GAP says this group is =D20= (the symmetries of the regular 10-gon).
Cf Table ref:20-1_fusion_table to the \( D_{10} \) fusion table:

#+name: d10_fusion_table
#+caption: Fusion table for \( \operatorname{Rep}(D_{10}) \).
| 1 | 2 | 3 | 4 |         5 |         6 |         7 |         8 |
| 2 | 1 | 4 | 3 |         8 |         7 |         6 |         5 |
| 3 | 4 | 1 | 2 |         5 |         6 |         7 |         8 |
| 4 | 3 | 2 | 1 |         8 |         7 |         6 |         5 |
| 5 | 8 | 5 | 8 | 1 + 3 + 7 |     7 + 8 |     5 + 6 | 2 + 4 + 6 |
| 6 | 7 | 6 | 7 |     7 + 8 | 1 + 3 + 8 | 2 + 4 + 5 |     5 + 6 |
| 7 | 6 | 7 | 6 |     5 + 6 | 2 + 4 + 5 | 1 + 3 + 8 |     7 + 8 |
| 8 | 5 | 8 | 5 | 2 + 4 + 6 |     5 + 6 |     7 + 8 | 1 + 3 + 7 |
**** \( \operatorname{Adj}(\operatorname{SO}(13)_2) \) is also \( \operatorname{Rep}(D_{13}) \)
#+name: d13-fusion-table
#+caption: Fusion Table for \( \operatorname{Rep}(D_{13}) \). Cf with \( \operatorname{Adj}(\operatorname{SO}(13)_2) \)
| 1 | 2 | 3         | 4         | 5         | 6         | 7         | 8           |
| 2 | 1 | 3         | 4         | 5         | 6         | 7         | 8           |
| 3 | 3 | 1 + 2 + 5 | 5 + 6     | 3 + 4     | 4 + 8     | 7 + 8     | 6 + 7       |
| 4 | 4 | 5 + 6     | 1 + 2 + 7 | 3 + 8     | 3 + 7     | 4 + 6     | 5 + 8       |
| 5 | 5 | 3 + 4     | 3 + 8     | 1 + 2 + 6 | 5 + 7     | 6 + 8     | 4 + 7       |
| 6 | 6 | 4 + 8     | 3 + 7     | 5 + 7     | 1 + 2 + 8 | 4 + 5     | 3 + 6       |
| 7 | 7 | 7 + 8     | 4 + 6     | 6 + 8     | 4 + 5     | 1 + 2 + 3 | 3 + 5       |
| 8 | 8 | 6 + 7     | 5 + 8     | 4 + 7     | 3 + 6     | 3 + 5     | 1 + 2 + 4   |


**** \( \operatorname{Adj}(\operatorname{SO}(24)_{2})\) is also \( \operatorname{Rep}(\mathbf{Z}_3 \rtimes Q_8) \)
#+name: 24-4_fusion_rules
#+caption: Rep(G) fusion rules for group with GAP ID =[24,4]=.
| 1 | 2 | 3 | 4 | 5             | 6         | 7         | 8         | 9         |
| 2 | 1 | 4 | 3 | 5             | 7         | 6         | 9         | 8         |
| 3 | 4 | 1 | 2 | 5             | 6         | 7         | 8         | 9         |
| 4 | 3 | 2 | 1 | 5             | 7         | 6         | 9         | 8         |
| 5 | 5 | 5 | 5 | 1 + 2 + 3 + 4 | 8 + 9     | 8 + 9     | 6 + 7     | 6 + 7     |
| 6 | 7 | 6 | 7 | 8 + 9         | 1 + 3 + 7 | 2 + 4 + 6 | 5 + 8     | 5 + 9     |
| 7 | 6 | 7 | 6 | 8 + 9         | 2 + 4 + 6 | 1 + 3 + 7 | 5 + 9     | 5 + 8     |
| 8 | 9 | 8 | 9 | 6 + 7         | 5 + 8     | 5 + 9     | 1 + 3 + 6 | 2 + 4 + 7 |
| 9 | 8 | 9 | 8 | 6 + 7         | 5 + 9     | 5 + 8     | 2 + 4 + 7 | 1 + 3 + 6 |

Perhaps an alternate realization of the category \( \operatorname{Adj}(SO(24)_2) \).
| =i= in =FusionTable(G)[i]= | AW Object Label |
|------------------------+-----------------|
|                      1 |               1 |
|                      2 |               2 |
|                      3 |               4 |
|                      4 |               3 |
|                      5 |               7 |
|                      6 |               5 |
|                      7 |               9 |
|                      8 |               8 |
|                      9 |               6 |


**** \( \operatorname{Adj}(\operatorname{SO}(24)_{2})\) is also \( \operatorname{Rep}(D_{12}) \)
#+name: 24-6_fusion_rules
#+caption: \( \operatorname{Rep}(D_{12}) \) fusion rules.
| 1 | 2 | 3 | 4 | 5             | 6         | 7         | 8         | 9         |
| 2 | 1 | 4 | 3 | 5             | 7         | 6         | 9         | 8         |
| 3 | 4 | 1 | 2 | 5             | 6         | 7         | 8         | 9         |
| 4 | 3 | 2 | 1 | 5             | 7         | 6         | 9         | 8         |
| 5 | 5 | 5 | 5 | 1 + 2 + 3 + 4 | 8 + 9     | 8 + 9     | 6 + 7     | 6 + 7     |
| 6 | 7 | 6 | 7 | 8 + 9         | 1 + 3 + 7 | 2 + 4 + 6 | 5 + 8     | 5 + 9     |
| 7 | 6 | 7 | 6 | 8 + 9         | 2 + 4 + 6 | 1 + 3 + 7 | 5 + 9     | 5 + 8     |
| 8 | 9 | 8 | 9 | 6 + 7         | 5 + 8     | 5 + 9     | 1 + 3 + 6 | 2 + 4 + 7 |
| 9 | 8 | 9 | 8 | 6 + 7         | 5 + 9     | 5 + 8     | 2 + 4 + 7 | 1 + 3 + 6 |


** Realizing some Multiplicity-Free Fusion Rules :categories:
:PROPERTIES:
:EXPORT_HUGO_SECTION: math
:EXPORT_FILE_NAME: realizing_fusion_rules
:EXPORT_OPTIONS: toc:nil
:END:
/Disclaimer: These results have not been subjected to the rigors of publication./
*** Fusion Rings
Classifying fusion categories is a huge task--likely impossible--but much effort has been made to find certain invariants to help distinguish fusion categories at various levels of structure.
One such invariant is the *fusion ring* associated to a fusion category \( \mathcal{C} \).
They are one of the more useful invariants of fusion categories, though they are incomplete at determining the whole structure of the category.
For instance, one area they fall short is the lack of their ability to capture the associativity isomorphism \( (X \otimes Y) \otimes Z\cong X \otimes (Y \otimes Z) \) and in certain cases the braiding \( X \otimes Y \cong Y \otimes X \).

**** The Fusion Ring of a Fusion Category
Recall that fusion categories are rigid, semisimple, abelian, \( k \)-linear, monoidal categories with finitely many simple objects, which include the monoidal unit \( \mathbf{1} \).
Let \( \mathcal{C} \) be a fusion category and denote the collection of simple objects by \( \mathcal{O}( \mathcal{C} )  = \left\{ X_0 , \ldots , X_n \right\} \) in an ordered fashion, choosing \( X_0 = \mathbf{1} \).
The direct sum on objects in a fusion (in fact, just abelian \( k \)-linear) category act as an "addition".
We can formalize this with the *Grothendieck group*: the free abelian group generated by the set \( \mathcal{O}( \mathcal{C} ) \), considered with equality up to isomorphism.

Continuing in the same way, the tensor product induces a kind of "multiplication" on the objects of \( \mathcal{C} \).
i.e., we have a multiplication structure on the Grothendieck group given by
\begin{equation}
\label{eq:2}
X_i\cdot X_{j} = [X_i \otimes X_j]
\end{equation}
where \( [X_i \otimes X_j] \) denotes the isomorphism class of the object \( X_i \otimes  X_j \).
The ring with this multiplication and addition is called the *Grothendieck ring* of the category \( \mathcal{C} \).

Notice that everything we've said so far doesn't use some key properties of fusion categories.
To start with, semisimplicity tells us that \( X_i \otimes X_j \) is a finite direct sum of the simple objects \( X_i \).
The general description of the isomorphism class of this object is then
#+name: fusion-decomp
\begin{equation}
\label{eq:fusion-decomp}
X_i \otimes X_j \cong \bigoplus_{k=1}^{n} N_{ij}^k X_k
\end{equation}
where \( N_{ij} \) are non-negative integers called the *fusion rules*.
The various structures above assemble a special kind of ring called a *fusion ring*.
A fusion ring is a unital based ring of finite rank.
We unroll the definitions:
#+begin_center
A based ring \( R \) is a ring that is free as a \( \mathbf{Z} \)-module equipped with the following:

a. <<structure-coeffs>> A \( \mathbf{Z}_+ \)-basis \( B = \left\{ b_i \right\}_{i\in I} \) such that \( b_i b_j = \sum_{k\in I}^{} c_{ij}^kb_k \) where \( c_{ij}^k\in \mathbf{Z}_+ \).
b. And identity \( 1 \) which is a non-negative linear combination of the basis
c. Let \( \tau : R \to \mathbf{Z} \) be the group homomorphism taking \( b_i \) to \( 1 \) if \( b_i \) appears in the decomposition of \( \mathbf{1} \), and \( 0 \) otherwise.
   We demand that there is an involution \( i \mapsto i^{*} \) of the ring such that the induced ring endomorphism is an anti-involution and the map \( \tau \) satisfies \( \tau(b_i b_j) =1 \) if \( i = j^{*} \) and \( 0 \) otherwise.

A based ring is called /unital/ if the identity \( 1 \) is a basis element.
We conclude by noting that /finite rank/ means there are finitely many basis elements.
#+end_center

The constraint in a is analogous to the fusion decomposition, while the involution in c comes from the rigidity of the category.
More details and standard results can be found in [[cite:&etingofTensorCategories2016 Chapter 3]].
*** Fusion Rings as an Invariant of Fusion Categories
To every fusion category we can associated a fusion ring.
Many questions in math come from asking about the opposite of a process we know we can carry out.
In this case, we can ask about the /categorifiability/ of a fusion ring.
That is, /given a fusion ring \( R \), can we construct a fusion category whose Grothendieck ring is \( R \)?/
One might even ask for more and ask if we can /uniquely/ construct a fusion category from a given fusion ring.

The answer to the latter is a definitive /no/.
One can construct two inequivalent fusion categories which descend to isomorphic fusion rings.
Not all hope is lost though, the theorem /Ocneanu rigidity/ states that there a finitely many equivalence classes of fusion categories with a given fusion ring.
The question of if there are finitely many fusion categories of any given rank is very much open.

To my knowledge, the question of categorifiability of a fusion ring has only a partial answer.
Namely, one can rule out categorifiability and unitary categorifiability via some properties of the fusion coefficients (see [[cite:&vercleyenLowRankFusion2023]]), but there is not a complete criteria of categorifiability of fusion rings.
*** Low Rank Fusion Rings
The benefit of working from fusion rings up to fusion categories is that fusion rings are highly computable (at least in comparison to fusion categories).
The authors [[cite:&vercleyenLowRankFusion2023]] used a computer algebra system to compute some fusion rings through rank \( 9 \).
They published a list of explicity known fusion rules along with some known (or conjectured) properties on the website [[https://anyonwiki.github.io/]].
You'll notice that some of the fusion rings have unknown properties, like whether or not they are categorifiable.
I set out to work on some of those properties.
*** Fusion Rules \( \operatorname{FR}^{8,0}_4 \)
The fusion rules \( \operatorname{FR}^{8,0}_4 \) (https://anyonwiki.github.io/pages/FRPages/FR_8_1_0_4.html) arise from  a rank \( 8 \) fusion ring which is multiplicity-free.
Here, multiplicity-free means that the fusion rules are either \( 0 \) or \( 1 \).
Up to now it was unknown if this ring was categorifiable, and I answered this question positively.

It was pointed out to me by my advisor that a good place to look for a categorification was a subcategory of the so-called metaplectic categories \( \operatorname{SO}(N)_2 \).
The details of these categories are beyond the scope of the article, but their fusion rules are known completely [[cite:&bruillardDimensionQuantumStatistic2018;&ardonneClassificationMetaplecticModular2016;&gustafsonMetaplecticCategoriesGauging2018]].

We can realize the fusion rules \( \operatorname{FR}^{8,0}_4 \) as "one half" of the metaplectic category \( \operatorname{SO}(12)_2 \).
We say "one half", because the category \( \operatorname{SO}(12)_2 \) is graded by the group \( \mathbf{Z}_{2} \times \mathbf{Z}_{2} \), and we can choose the fusion category generated by the trivial graded component and the graded component associated to \( (1,0) \) (or equivalently, \( (0,1) \)).

One can use the results of [[cite:&bruillardDimensionQuantumStatistic2018]] to compute the complete set of fusion rules of the objects of \( \operatorname{SO}(12)_2 \) chosen accordingly.
A summary of the results of this computation are presented in the tables below.
Compare these results to the fusion rules presented on the [[https://anyonwiki.github.io/pages/FRPages/FR_8_1_0_4.html][AnyonWiki]].

For an example of one such computation, we work out \( X_1 \otimes V_1 \).
The multiplicity of any simple object in the direct sum decomposition can be found using the Frobenius reciprocity laws.
That is, for simple objects \( A,B,C \), \( N_{A,B}^C = N_{A^{*},C}^B = N_{C, B^{*}}^A \).

The multiplicity of \( X_i \) in the decomposition of \( X_1 \otimes  V_1 \) is given by \( N_{X_1, V_1}^{X_i} = N_{X_1^{*} , X_i}^{V_1} = N_{X_1 , X_i}^{V_1} = 0 \) by self-duality of simple objects.
A simple object \( X \) is self-dual if \( N_{X,X}^{\mathbf{1}}\neq 0 \).
i.e. that \( \mathbf{1} \) appears in the direct sum decomposition of \( X \otimes X \).
Similarly, \( N_{X_1 , V_1}^f = N_{X_1 ,f}^{V_1} = 0 \) and similarly for the multiplicity of \( g,fg \).
Finally, \( N_{X_1 , V_1}^{V_1} = N_{V_1 , V_1}^{X_1}= 1 \) and similarly for \( N_{X_1 , V_1}^{V_2}=1 \).

#+name: one_half_so_12_dimension
#+caption: Dimensions of simple objects in "one half" \( \operatorname{SO}(12)_2 \)
| Object    | Dimension      |
|-----------+----------------|
| *1*         | \( 1 \)        |
| \( g \)   | \( 1 \)        |
| \( f \)   | \( 1 \)        |
| \( fg \)  | \( 1 \)        |
| \( X_0 \) | \( 2 \)        |
| \( X_1 \) | \( 2 \)        |
| \( V_1 \) | \( \sqrt{6} \) |
| \( V_2 \) | \( \sqrt{6} \) |


#+caption: Fusion rules for "one half" \( \operatorname{SO}(12)_2 \)
#+name: one_half_so12_fusion_rules
| Object           | \( \mathbf{1} \) | \( f \)          | \( g \)          | \( fg \)         | \( X_0 \)                          | \( X_1 \)                           | \( V_1 \)                                         | \( V_2 \)                                           |
|------------------+------------------+------------------+------------------+------------------+------------------------------------+-------------------------------------+---------------------------------------------------+-----------------------------------------------------|
| \( \mathbf{1} \) | \( \mathbf{1} \) | \( f \)          | \( g \)          | \( fg \)         | \( X_{0} \)                        | \( X_{1} \)                         | \( V_{1} \)                                       | \( V_{2} \)                                         |
| \( f \)          | --               | \( \mathbf{1} \) | \( fg \)         | \( g \)          | \( X_1 \)                          | \( X_0 \)                           | \( V_1 \)                                         | \( V_{2} \)                                         |
| \( g \)          | --               | --               | \( \mathbf{1} \) | \( f \)          | \( X_1 \)                          | \( X_0 \)                           | \( V_2 \)                                         | \( V_{1} \)                                         |
| \( fg \)         | --               | --               | --               | \( \mathbf{1} \) | \( X_0 \)                          | \( X_1 \)                           | \( V_2 \)                                         | \( V_1 \)                                           |
| \( X_{0} \)      | --               | --               | --               | --               | \(\mathbf{1}\oplus fg \oplus X_1\) | \( f\oplus g\oplus fg \oplus X_0 \) | \( V_{1} \oplus V_2 \)                            | \( V_{1} \oplus V_1 \)                              |
| \( X_{1} \)      | --               | --               | --               | --               | --                                 | \(\mathbf{1} \oplus fg \oplus X_1\) | \( V_{1} \oplus V_2 \)                            | \( V_{1} \oplus V_2 \)                              |
| \( V_{1} \)      | --               | --               | --               | --               | --                                 | --                                  | \( \mathbf{1}\oplus f \oplus X_{0}\oplus X_{1} \) | \( f \oplus fg \oplus X_{0} \oplus X_{1} \)         |
| \( V_{2} \)      | --               | --               | --               | --               | --                                 | --                                  | --                                                | \( \mathbf{1} \oplus f \oplus X_{0} \oplus X_{1} \) |
*** Fusion Rules \( \operatorname{FR}^{9,0}_{7} \)
It turns out that a categorification of the fusion rules \( \operatorname{FR}^{9,0}_7 \) (https://anyonwiki.github.io/pages/FRPages/FR_9_1_0_7.html) is nearly identical to that of \( \operatorname{FR}^{8,0}_4 \), just with a different choice of metaplectic category.
In this instance, we choose "one half" of \( \operatorname{SO}(16)_2 \) using the exact same method to choose generating objects.
The results are summarized in the tables below.

#+name: one_half_so_16_dimension
#+caption: Dimensions of simple objects in "one half" \(\operatorname{SO}(12)_2 \)
| Object    | Dimension                   |
|-----------+-----------------------------|
| *1*         | \( 1 \)                     |
| \( g \)   | \( 1 \)                     |
| \( f \)   | \( 1 \)                     |
| \( fg \)  | \( 1 \)                     |
| \( X_0 \) | \( 2 \)                     |
| \( X_1 \) | \( 2 \)                     |
| \( X_2 \) | \( 2 \)                     |
| \( V_1 \) | \(2 \sqrt{2}\)              |
| \( V_2 \) | \(2 \sqrt[\phantom{a}]{2}\) |

#+name: one_half_so16_fusion_rules
#+caption: Fusion rules for "one half" \( \operatorname{SO}(16)_2 \)
|                  | \( \mathbf{1} \) | \( f \)          | \( g \)          | \( fg \)         | \( X_0 \)                          | \( X_1 \)                                  | \( X_2 \)                             | \( V_1 \)                                                   | \( V_2 \)                                                      |
|------------------+------------------+------------------+------------------+------------------+------------------------------------+--------------------------------------------+---------------------------------------+-------------------------------------------------------------+----------------------------------------------------------------|
| \( \mathbf{1} \) | \( \mathbf{1} \) | \( f \)          | \( g \)          | \( fg \)         | \( X_{2} \)                        | \( X_{1} \)                                | \( X_2 \)                             | \( V_{1} \)                                                 | \( V_{2} \)                                                    |
| \( f \)          | --               | \( \mathbf{1} \) | \( fg \)         | \( g \)          | \( X_2 \)                          | \( X_1 \)                                  | \( X_0 \)                             | \( V_1 \)                                                   | \( V_{2} \)                                                    |
| \( g \)          | --               | --               | \( \mathbf{1} \) | \( f \)          | \( X_2 \)                          | \( X_1 \)                                  | \( X_0 \)                             | \( V_2 \)                                                   | \( V_{1} \)                                                    |
| \( fg \)         | --               | --               | --               | \( \mathbf{1} \) | \( X_0 \)                          | \( X_1 \)                                  | \( X_2 \)                             | \( V_2 \)                                                   | \( V_1 \)                                                      |
| \( X_{0} \)      | --               | --               | --               | --               | \(\mathbf{1}\oplus fg \oplus X_1\) | \(X_0\oplus X_2\)                          | \(f \oplus g \oplus X_1\)             | \( V_{1} \oplus V_2 \)                                      | \( V_{1} \oplus V_2 \)                                         |
| \( X_{1} \)      | --               | --               | --               | --               | --                                 | \(\mathbf{1} \oplus f \oplus g \oplus fg\) | \(X_0\oplus X_2\)                     | \( V_{1} \oplus V_2 \)                                      | \( V_{1} \oplus V_2 \)                                         |
| \( X_{2} \)      | --               | --               | --               | --               | --                                 | --                                         | \( \mathbf{1} \oplus fg \oplus X_1 \) | \( V_{1} \oplus V_2 \)                                      | \( V_{1} \oplus V_2 \)                                         |
| \( V_{1} \)      | --               | --               | --               | --               | --                                 | --                                         | --                                    | \( \mathbf{1}\oplus f \oplus X_{0}\oplus X_{1}\oplus X_2 \) | \( f \oplus fg \oplus X_{0} \oplus X_{1} \)                    |
| \( V_{2} \)      | --               | --               | --               | --               | --                                 | --                                         | --                                    | --                                                          | \( \mathbf{1} \oplus f \oplus X_{0} \oplus X_{1} \oplus X_2 \) |

*** Bibliography
[[bibliography:~/Documents/bib/zotero_refs.bib]]
** Quantum Computing, Braids, and Modular Categories :math:categories:
:PROPERTIES:
:EXPORT_HUGO_SECTION: math
:EXPORT_FILE_NAME: quantum_comp_and_modular_categories
:END:

*** Introduction
Quantum computing (QC) is an exciting new paradigm of computation, promising exponential speedup from state-of-the-art classical algorithms in certain computing tasks.
Despite vigorous research from all sides of the task, obstacles to a quantum computer architecture that is scalable and tolerant to errors remain hard to overcome.

Qubits in existing models of quantum computation (such as trapped-ion models) are sensitive to their environment.
Such sensitivities of the environment make qubits liable to introducing noise that dominates the computation we'd like to measure.
To ensure we can recover usable data, we'd (approximately) need on the order of thousands of physical qubits per logical qubit to near-guarantee our computation is correct.
This would be no issue if current QC implementations were highly scalable, but they are not.
Topological quantum computing is a theoretical basis to address both these issues simultaneously.

*** Anyons and their statistics
While traditional QC implementations use bosons and fermions for qubits, topological quantum computing (TQC) uses /anyons/.
Recall that two bosons exchange in a wave function causing a global phase shift \( +1 \) (i.e. \( | \varphi_1 \varphi_2 \rangle = | \varphi_2 \varphi_1 \rangle\)).
Conversely, fermions exchange with a global phase shift \( -1 \), so \( | \varphi_1 \varphi_2 \rangle = - | \varphi_2 \varphi_1 \rangle \).
Anyons are type of quasiparticle that allow for more general phase shifts \( e^{i\theta} \) for some value of \( \theta \).
We recover bosons and fermions at \( \theta= 0 \) and \( \theta=\pi \), respectively.
Anyons can take any statistics between Bose-Einstein statistics and Fermi-Dirac statistics and beyond, corresponding to values \( 0 \leqslant \theta \leqslant 2\pi \).

I've somewhat lied by omission in the previous paragraph.
The global phase shifts corresponding to \( e^{i\theta} \) are actually relevant to the so-called /abelian anyons/.
One can generalize this phase shift further to an even larger class of unitary operators satisfying the [[https://en.wikipedia.org/wiki/Yang%E2%80%93Baxter_equation][Yang-Baxter equation]]; such quasiparticles are /non-abelian anyons/.
These non-abelian anyons are the building blocks to encoding information in TQC.
The question remains--/what does this buy us?/
I've already alluded to how TQC may be less sensitive to environmental noise than classical qubits, so we should understand how.

#+name: anyonexchange
#+caption: Inequivalent exchanges for identical anyons.
#+attr_html: :width 150%
[[file:figures/anyon_exchange.svg]]

When thinking about how anyons interact with each other, we must think topologically.
That is, we can do everything up to a "smooth/continuous" deformation.
In one dimension of space, nothing interesting can happen: we cannot exchange anyons at all.
In three dimensions of space, everything is trivial.
If an anyon moves around another anyon back to its starting position, one can "drag" the path and shrink it simultaneously, so that topologically the path is indistinguishable from the particle not moving at all.

In two dimensions of space, things get more interesting.
In a flatland with two particles, there are two topologically distinct paths a particle can take in the plane.
They are illustrated in Figure [[anyonexchange]].
In fact, there are infinitely many: one can wind a particle around the other as many times as needed to produce a path distinct from the others.
#+name: braids
#+caption: Braids on n=3 strands traced out over time progression.
#+attr_html:  :width 150%
[[file:figures/braids.png]]

At each slice of time, the position of anyons in flatland correspond to points in a plane.
As we progress time, the trajectories of the anyons trace out paths akin to strands of string.
The strings cannot cross through each other, as this would mean the particles "collide" at some point in time.
Figure [[braids]] illustrates this phenomenon, with the arrow indicating the passage of time.

Mathematically, the collection of all these trajectories for some fixed \( n \) particles--disallowing the strands doubling back--form a group under composition: it is the *braid group on \( n \) strands*, denoted \( \mathcal{B}_n \).
Here, the braid group is an instance of a more general kind of group called a *motion group*.
The mathematical formulation of this is to say that the braid group on \( n \) strands is the motion group of a disjoint union of points embedded in a compact box.
More general motion groups corresponding exist, such as motions of circles or trefoils in a compact box.
These are quite a bit more complicated, and we know little about them compared to the braid groups.

To each braiding we want to associate a unitary operator (read: a quantum gate), so we can say that mathematically, the statistics of \( n \) anyons correspond to certain unitary representations \( \mathcal{B}_n \to U(V) \) of the braid group on \( n \) strands.
From a practical perspective, the act of applying a quantum gate to a system of anyons would correspond to braiding them.
This basis for computing is intuitively less sensitive to environmental noise in the sense that the topological properties of braids are more stable under small perturbation.
One can imagine that it is easier for a ball to bump into a wall from a slight gust of wind than to rearrange two crossed strings so that the lower string lies on top by cutting and rearranging.
This comparison is not unlike the difference between the sensitivity of qubits in the classical QC world and the TQC world.
Study of braid groups, motion groups, and the unitary representations of these groups shed light on the behavior of anyons, making it a subject of physical interest, and not just one of intrinsic beauty.

*** Modular Categories
We switch gears a bit to discuss the other data of anyon systems, of which there is many.
The study of braids and their unitary representations will capture how the interactions of anyons in space alter the data of the global quantum system, but says nothing of the data internal to the particles, and how that data changes.

Anyons carry lots of intrinsic data.
One can formalize the physics of anyons along with certain symmetries and stabilities and collect them into a set of equations to solve for.
Kitaev [[cite: &kitaevAnyonsExactlySolved2006 Appendix E]] suggested that the algebraic combinatorics of the solutions to these equations can be formalized in the language of *unitary modular categories*.

The language of categories came about much earlier as a language of formalize analogous phenomena that occur in seemingly unrelated areas of mathematics.
Recently, categories enriched with extra structure have been studied due to their flexibility in encoding certain data.
Technically speaking, modular categories arose from the study of conformal field theories, which are a kind of quantum field theory that exhibit certain topological invariances.

The definition of a modular category is a bit complex; it is a ribbon fusion category with nondegenerate \( S \)-matrix.
The interested reader can refer to Figure [[fig:modular_definition_tree]] for a tree of what each of these terms imply.
Each property/structure is interesting in its own right.

#+name: fig:modular_definition_tree
#+begin_src plantuml :file figures/modular_tree.png :results file
@startmindmap modularmap
skinparam backgroundColor transparent
,*[#LightGray] modular
,**[#LightGray] ribbon
,***[#LightGray] braided
,***[#LightGray] twist compatible with duals
,**[#LightGray] fusion
,***[#LightGray] rigid
,***[#LightGray] semisimple
,***[#LightGray] abelian
,***[#LightGray] k-linear
,***[#LightGray] monoidal
,***[#LightGray] finitely many simple objects including unit
,**[#LightGray] nondegenerate S-matrix
,***[#LightGray] unit object is the only transparent object
@endmindmap
#+end_src
#+caption: Definition of monoidal category and what each term means. Moving to the right means "has this property".
#+RESULTS: fig:modular_definition_tree
[[file:figures/modular_tree.png]]



The reader might ask if the "braided" in Figure [[fig:modular_definition_tree]] is related to the braiding discussed for anyons.
Indeed it is, the braiding in a unitary modular category corresponds to braiding of anyons.
There is an comprehensive dictionary of the correspondence between unitary modular categories and the physical interpretation of what the data represent.
[[cite:A more detailed dictionary is found in;&rowellMathematicsTopologicalQuantum2018;Table 1]].

#+begin_export hugo
<style>
sane-table#table {
    margin-left: auto;
    margin-right: auto;

}
sane-table table {
  border-collapse: collapse;
  width: 100%;
  margin-left: auto;
  margin-right: auto;
}
.sane-table th,
.sane-table td {
  padding: 0.25rem;
  text-align: left;
  border: 1px solid #ccc;
  margin-left: auto;
  margin-right: auto;
}
</style>
#+end_export
#+name: anyon_dictionary
#+attr_html: :class sane-table :align center
#+caption: Synonyms from the worlds of unitary modular categories and anyon systems
| Unitary Modular Category | Anyon System     |
|--------------------------+------------------|
| Simple object            | Anyon            |
| Tensor product           | Fusion           |
| Dual object              | Antiparticle     |
| Evaluation               | Annihilation     |
| Coevaluation             | Creation         |
| Unit object              | Vacuum Sector    |
| Twist                    | Topological Spin |

Classifying unitary modular categories up to some notion of equivalence is therefore equivalent to classifying systems of anyons.
This is a difficult problem, but is thought to be possible, and positive signs have appeared.
It was shown in [[cite:&bruillardRankfinitenessModularCategories2016]] that there are only finitely many modular categories for a given rank.
Physically, this would mean that a system \( n \) anyons can only interact nontrivially in finitely many distinct ways for each amount \( n \).

The ergonomics of modular categories can be challenging given the sheer number of equations to solve, but down-to-earth examples exist.
Perhaps the most well known is \( \mathsf{Vec} \), the category of finite dimensional vector spaces.
This is a rank \( 1 \) modular category with \( S \)-matrix \( (1) \) and \( T \)-matrix \( (1) \).
Ok, not very interesting...
This is indeed the most trivial example of a modular category, though more examples exist that are only slightly more difficult to understand.
For example, the category of metric groups \( (G,q) \) is equivalent to the category of pointed modular categories.
[[cite:see &etingofTensorCategories2016 chap 8]].

Despite the difficulty of classifying modular categories, this task enjoys deep connections to representation theory, quantum field theory, and condensed matter physics.
*** Conclusion
TQC is an exciting field gaining more and more traction as the years go by.
Experimental evidence for topological matter with gapped phases earned Thouless, Kosterlitz, and Haldane the Nobel Prize in Physics in 2016.
Microsoft has staked its entire quantum computing research division on the premise of TQC.
The study of modular categories is advancing at rapid pace, and we are learning more and more about representation theory and quantum algebra along the way.
*** Bibliography
[[bibliography:~/Documents/bib/zotero_refs.bib]]

*** Notes :noexport:
- quantum computing is not fault tolerant, based on physical limitations and introductions of noise in trapped quantum systems
- modular effectively model systems of anyon quasiparticles, the main ingredient to TQC (Kitaev)
- TQC allows for scalable fault-tolerant QC, where the error correction is performaed at the hardware level
  - This is perhaps its strongest merit
** DRAFT A "Yoga" to Realizing Multiplicity-Free Fusion Rules :math:categories:noexport:

Since writing about [[*Realizing some Multiplicity-Free Fusion Rules][realizing multiplicity-free fusion rules]], I've gone through more of the [[https://anyonwiki.github.io/][AnyonWiki]] database and realized more fusion rules, picking up some techniques to hint at possible answers along the way.
I hesitate to call this a yoga (whatever that means, anyway), because really it's just a set of heuristics following the information provided.

Before discussing the heuristics and how they might apply, let's go over some information provided by the AnyonWiki (AW) about the computed fusion rings.

*** Numerical Data for Fusion Rings
There are two basic types of numerical data for fusion rings: the rank and the Frobenius-Perron (or "quantum") dimensions.
The rank is simple: it is the number of \( \mathbf{Z}_+ \)-basis elements of the ring.
Due to computational intractability, the AW lists only mutliplicity-free fusion rings of rank 1-9.

The second numerical data associated to a fusion ring is the Frobenius-Perron (FP) dimension.
Not only is the ring assigned an FP dimension, but the basis elements are assigned one too.
Dimensions can thus provie discriminatory power between two fusion rules of the same rank.

Despite the similarities in behavior between fusion categories and \( \mathsf{Vec} \), the category of finite dimension vector spaces, FP dims can be more general than the familiar dimensions of vector spaces.
For example, the [[https://anyonwiki.github.io/pages/FRPages/FR_2_1_0_2.html][Fibonacci category]] has a simple object of dimension \( \phi \), the golden ratio.
A higher rank example of Frobenius-Perron dimensions for basis elements is presented in Table

|               Particle | Numeric |     Symbolic |
|------------------------+---------+--------------|
|                      1 |      1. |            1 |
|                      2 |      1. |            1 |
|                      3 |      1. |            1 |
|                      4 |      1. |            1 |
|                      5 |      2. |            2 |
|                      6 |      2. |            2 |
|                      7 | 2.44949 | \(\sqrt{6}\) |
|                      8 | 2.44949 | \(\sqrt{6}\) |
| \(\mathcal{D}_{FP}^2\) |     24. |           24 |

** LAWRGe 2023 Notes :math:conference:notes:
:PROPERTIES:
:EXPORT_HUGO_SECTION: math
:EXPORT_FILE_NAME: LAWRGe_2023_notes
:END:
#+toc: headlines 2 local
#+include: "~/Documents/org/notes.org::*LAWRGe Workshop"
* Computing
:PROPERTIES:
:EXPORT_HUGO_SECTION: comp
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :type post
:END:
** Computing
:PROPERTIES:
:EXPORT_HUGO_SECTION: comp
:EXPORT_FILE_NAME: _index
:EXPORT_HUGO_MENU: :menu main
:END:
** Configuring =meow= for Friendlier LaTeX Editing :emacs:meow:
:PROPERTIES:
:EXPORT_HUGO_SECTION: comp
:EXPORT_FILE_NAME: configuring_meow_friendly_latex
:END:
/TL;DR: We implement some configuration to recover functionality possible in evil-tex in the meow modal editing scheme./
/This article assumes some familiarity with the evil and meow modes./
#+toc: headlines 2 local
Having ditched =evil-collection= to get familiar with the vanilla emacs keybindings, I surprisingly found myself satisfied with many of the facilities emacs provides out-of-the-box for editing text.
Alas, I feel modal editing is something I prefer, so I've adopted [[https://github.com/meow-edit/meow][meow]].
I chose meow for a few reasons:
- Trivial to extend and hack on
- The "selection-first" ethos is intriguing
- No dependencies
- Prefers built-in methods for various tasks
- Keypad mode offers a great, lighter weight alternative to the =SPC= DOOM leader with evil mode

So far, it's been an enjoyable experience, but one evil-mode package--=evil-tex=--gave me pause.
*** =evil-tex=
[[https://github.com/iyefrat/evil-tex][evil-tex]] is an extension to evil that adds support for "vimmable" text objects in LaTeX syntax.
As an example, let =|= denote the location of the point when using evil mode.
Suppose we're given the situation:
#+begin_example
The qu|ick brown fox jumps over the lazy dog.
#+end_example
In =evil-normal-mode= you can type the keys =ciw= to "Change Inner Word", deleting the work =quick= and placing you in =evil-insert-mode=.

If =w= denotes the "word" evil object, evil-tex offers the math-mode text object, allowing this same loop to be performed but inside LaTeX syntax.
Consider the following inline math expression with point =|=:
#+begin_example
\( X\cong | Y \)
#+end_example
With =evil-tex-mode= enabled, and inside =evil-normal-mode=, we can press =cim= to "Change Inner Math", deleting all the text within the =\( \)= delimiters and placing us in insert mode.
This is just one example of what evil-tex offers; a more comprehensive picture is in the documentation.

*** Doing Our Own Thing
Meow uses =things= (lit.) to demarcate sections of text that you can navigate around and select.
For example, some things that come preloaded with meow are sentences, defuns, paragraphs, buffers, windows, and lines.
When a thing is defined, you can press =, <THING_KEY>= to select the inner part of the thing, where =<THING_KEY>= is the key associated with that thing (e.g. =l= for line, =d= for defun).
Similarly, you can press =. <THING_KEY>= to select to the bounds of the thing.
Here's a demo on how that works with the =symbol= thing, mapped to =e=:
#+CAPTION: Demo of symbol thing in meow
[[file:~/Videos/meow-symbol-inner.gif]]

There's a parallel between this behavior and the "inner <object>" and "all <object>" behavior in evil.
For example, suppose we have a text object in evil that picks out the line the point is on, mapped to =l=.
Then the key sequence =c i l= in evil mode (to "Change Inner Line") could be replicated in meow with =, l c=.
We can take this idea and help make meow friendlier for LaTeX editing.

In meow, it's easy to define a =thing= with the function =(meow-thing-register)=.

*** Inline Math
Let's register a =thing= that picks out the LaTeX inline math environment =\( \)=.
The simplest way to do this is using the pair matching:
#+begin_src emacs-lisp
(meow-thing-register 'inline-math
                     '(pair ("\\(") ("\\)"))
                     '(pair ("\\(") ("\\)") ) )
#+end_src

Now we can map this thing to a key:
#+begin_src emacs-lisp
(add-to-list 'meow-char-thing-table '(?m . inline-math))
#+end_src

Now, when we're inside an inline math environment, we can press =, m= to select all the text within the math environment, and =. m= to select all of the math environment.
#+CAPTION: Demo of our user-defined math thing
[[file:~/Videos/meow-math-demo.gif]]


The bindings =, m= and =. m= replicate the evil-tex object identification =i m= and =a m=, respectively.

*** Environments
At their core, LaTeX environments look like
#+begin_example
\begin{ENV}
...
\end{ENV}
#+end_example

Happily, the code in =evil-tex= uses to grab the LaTeX environment objects is essentially some vanilla elisp, without dependency on evil internals.
In particular, we focus on this code:
#+begin_src emacs-lisp
(require 'latex)
(setq evil-tex-select-newlines-with-envs nil)

(defun evil-tex--select-env ()
  "Return (outer-beg outer-end inner-beg inner-end) for enviornment object.

If `evil-tex-select-newlines-in-envs' is non-nil, the inner
variant would NOT include newlines proceeding the \\begin and
preceding the \\end.

\\begin{foobar}{bar}[baz]
^outer-beg              ^inner-beg
qux
\\end{foobar}
^inner-end  ^outer-end"
  (let (outer-beg outer-end inner-beg inner-end)
    (save-excursion
      (cond
       ;; `LaTeX-find-matching-begin' doesn't like being exactly on the \\begin
       ((looking-at (regexp-quote "\\begin{"))
        t)
       ;; `LaTeX-find-matching-begin' doesn't like being near the } of \\end{}
       ((or (= (char-before) ?})
            (= (char-after) ?}))
        (backward-char 2)
        (LaTeX-find-matching-begin))
       (t
        (LaTeX-find-matching-begin)))
      ;; We are at backslash of \\begin
      (setq outer-beg (point))
      (forward-sexp)
      (while (or
              (= (char-after) ?{)
              (= (char-after) ?\[))
        (forward-sexp))
      (when (and evil-tex-select-newlines-with-envs
                 (looking-at "\n[ \t]*"))
        (goto-char (match-end 0)))
      (setq inner-beg (point))
      (goto-char (1+ outer-beg))
      (LaTeX-find-matching-end)        ; we are at closing brace
      (setq outer-end (point))
      (search-backward "\\end")        ; goto backslash
      (when (and evil-tex-select-newlines-with-envs
                 (looking-back "\n[ \t]*" (- (point) 10)))
        (goto-char (match-beginning 0)))
      (setq inner-end (point))
      (list outer-beg outer-end inner-beg inner-end))))
#+end_src
The only evil-specific thing in this function is =evil-tex-select-newlines-with-envs=, which is a self-explanatory user-defined variable.
We can write functions that slice off the output of this function to get a cons cell of the inner bounds and outer bounds respectively, and use those functions to define our things.
The functions to get the inner and outer parts are
#+begin_src emacs-lisp
;; Select inner and outer environment pairs
(defun my/meow-inner-env ()
  (let ((result (evil-tex--select-env)))
    (cons (nth 2 result) (nth 3 result))))

(defun my/meow-outer-env ()
  (let ((result (evil-tex--select-env)))
    (cons (nth 0 result) (nth 1 result))))
#+end_src
Now the configuration for our environment thing is just
#+begin_src emacs-lisp
(meow-thing-register 'latex-env
                     #'my/meow-inner-env #'my/meow-outer-env)

(add-to-list 'meow-char-thing-table '(?E . latex-env))
#+end_src


#+CAPTION: Demo of our user-defined latex-env thing
[[file:~/Videos/meow-latex-env.gif]]

*** LaTeX Parentheses Delimiters
Parentheses delimitiers in math mode are a bit of a tricky case.
We'd like to include all possible delimiters in math mode, including the ones modified by =\left \right=, =\bigl \bigr=, etc.
In addition to that, we'd hope to also capture basic delimiters like =(  )= and =[ ]= and =\{ \}=.
To do this, we will do the following:
- create a master list of all possible LaTeX parentheses delimiters, including unmodified ones like =( )=
- use meow's internal =meow--thing-pair-function= to find all pairs we can see around the point
- find the match closest to the point
This will cover all cases of where the point could be, even in deeply nested parentheses.

First we declare our master list of delimiters:
#+begin_src emacs-lisp
(setq meow--latex-mod-delim-pairs
      (cl-loop for (l r)
               in '(( "(" ")" )
                    ( "\\[" "\\]" )
                    ( "\\\\{" "\\\\}" )
                    ( "\\\\lvert" "\\\\rvert" )
                    ( "\\\\lVert" "\\\\rVert" )
                    ( "\\\\langle" "\\\\rangle" ))
               nconc
               (cl-loop for (pre-l pre-r)
                        in '( ("" "")   ;; after concatting corresponds to unmodified delim
                              ( "\\\\left"  "\\\\right")
                              ( "\\\\bigl"  "\\\\bigr")  ("\\\\big"  "\\\\big")
                              ( "\\\\biggl" "\\\\biggr") ("\\\\bigg" "\\\\bigg")
                              ( "\\\\Bigl"  "\\\\Bigr")  ("\\\\Big"  "\\\\Big")
                              ( "\\\\Biggl" "\\\\Biggr") ("\\\\Bigg" "\\\\Bigg"))
                        collect (cons (concat pre-l l) (concat pre-r r)))))
#+end_src
The next two functions are helpers for the main method.
#+begin_src emacs-lisp
(defun append-bounds-distance (pair)
  "Appends the minimum distance of match pair to point"
  (if pair
      (cons pair (min (-  (point) (car pair))  (- (cdr pair) (point))))
    'nil))

(defun find-min-distance-match (matches-with-distances)
  "Finds the match with minimal distance to point"
  (let ((nearest-match (cons (point) (point)))
        (min-distance (float 1.0e+INF)))
    (dolist (match matches-with-distances)
      (when (cdr match)
        (when  (> min-distance (cdr match) )
          (setq nearest-match (car match))
          (setq min-distance (cdr match)))))
    nearest-match))
#+end_src

Now here's our main function:
#+begin_src emacs-lisp
(defun my/meow-latex-paren-search (near)
  "Find nearest LaTeX parenthesis bounds.
NEAR denotes if match should be inner or bounds"
  (interactive)
  (let ((found-pairs (list )))
    (dolist (leftright meow--latex-delim-pairs)
      (push  (meow--thing-pair-function
              (car leftright) (cdr leftright) near) found-pairs))
    (let ((bounds-with-distances (mapcar #'append-bounds-distance found-pairs)))
      (find-min-distance-match bounds-with-distances))))
#+end_src
Don't let this elisp scare you; it does exactly what I said when I laid out the approach to this problem.
That is, it generates a list of delimiters we find aroud the point, and finds the closest such match, returning it.

The =near= argument specifies if we want to match the inner or bounds of the match.
It will be =t= for inner and =nil= for bounds.
We can hook this into two new functions for the inner and bounds matching, respectively.
#+begin_src emacs-lisp
(defun my/meow-latex-paren-bounds ()
  (my/meow-latex-paren-search nil))

(defun my/meow-latex-paren-inner ()
  (my/meow-latex-paren-search t))

(meow-thing-register 'latex-delim
                     #'my/meow-latex-paren-inner
                     #'my/meow-latex-paren-bounds)

(add-to-list 'meow-char-thing-table '(?D . latex-delim))
#+end_src
Here's what the result looks like:

#+CAPTION: Demo of our user-defined delimiter thing
[[file:~/Videos/meow-delim-demo.gif]]

Note that the way we have defined the delimiters makes it trivial to add/subtract delimiters from the list of things we want to match.

*** Closing Thoughts
What I've shown here is a very small, quickly-put-together look at the hackability of meow.
The documentation for meow is very comprehensive, and users should customize meow to their heart's content.
After all, one of the selling points of meow is how easy it is to "roll your own" modal editor.
Continued refinements of your workflow attuned to your particular idiosyncracies is a rewarding endeavour.
I hope I've brought some inspirational ideas here.
** A =meow-state= for speedy org structure navigation :emacs:meow:
:PROPERTIES:
:EXPORT_HUGO_SECTION: comp
:EXPORT_FILE_NAME: meow_state_org_speed
:END:

/TL;DR: We implement a =meow-state= for quick navigation of =org-mode= document structure./

I've been very pleased with my switch to the =meow= modal editor, but one of the downsides of it is no obvious way to use [[https://orgmode.org/manual/Speed-Keys.html][speed keys]] in =org-mode=.
Namely, the meow normal state maps would clash with the speed key definitions.
One could just redefine the speed keys to avoid the normal state maps, or redefine the normal state maps themselves, but that's no fun.

In the words of Mickey Petersen, org speed keys offer a kind of "transient modality" to default emacs keybindings.
But meow is /already/ a modal editing scheme, there's no benefit that I can see to making speed keys a transient behavior, especially with how much I use org-mode.

We take a different approach and define our own =meow-state= to navigate org structure.
Meow offers excellent support for defining your own states.
For those who use evil, this like the user being able to define a different mode under which we can edit and navigate, much like =evil-normal-state= and =evil-visual-state=.
Like evil, each =meow-state= has its own set of keybindings that call specific functions.
We will define a state =meow-org-motion-state= that will be used for navigating org documents.
Doing so is shockingly simple; most of the code is lifted directly from [[https://github.com/meow-edit/meow/blob/master/CUSTOMIZATIONS.org][the meow customization documentation.]]

The entire code in defining the state is this:
#+begin_src emacs-lisp
(setq meow-org-motion-keymap (make-keymap))
(meow-define-state org-motion
  "Org-mode structural motion"
  :lighter "[O]"
  :keymap meow-org-motion-keymap)

(meow-define-keys 'org-motion
  '("<escape>" . meow-normal-mode)
  '("i" . meow-insert-mode)
  '("g" . meow-normal-mode)
  '("u" .  meow-undo)
  ;; Moving between headlines
  '("k" .  org-previous-visible-heading)
  '("j" .  org-next-visible-heading)
  ;; Moving between headings at the same level
  '("p" .  org-backward-heading-same-level)
  '("n" .  org-forward-heading-same-level)
  ;; Moving subtrees themselves
  '("K" .  org-subtree-up)
  '("J" .  org-subtree-down)
  ;; Subtree de/promotion
  '("L" .  org-demote-subtree)
  '("H" .  org-promote-subtree)
  ;; Completion-style search of headings
  '("v" .  consult-org-heading)
  ;; Setting subtree metadata
  '("l" .  org-set-property)
  '("t" .  org-todo)
  '("d" .  org-deadline)
  '("s" .  org-schedule)
  '("e" .  org-set-effort)
  ;; Block navigation
  '("b" .  org-previous-block)
  '("f" .  org-next-block)
  ;; Narrowing/widening
  '("N" .  org-narrow-to-subtree)
  '("W" .  widen))

(meow-define-keys 'normal
  '("O" . meow-org-motion-mode))
#+end_src

#+RESULTS:

Whilst being easy to define, this configuration is also very easy to read.
Every keymap is self explanatory.
In particular, we implement meow-style up-down nagivation of subtrees with =jk=, and add level-restricted motion with =np=.
Subtree metadata can be edited from this state without exiting the state, and source block navigation is added--useful for literate programmers.

There's one major benefit to using a custom =meow-state= instead of attempting to get speed keys working: *this state is available anywhere in the buffer.*
With speed keys, the point *must* be at the beginning of an org heading.
With our custom state, a simple press of =O= while in =meow-normal-mode= puts us in navigation mode.
This makes navigation of org documents fast and accessible in a way that is superior to speed keys, something afforded to us by adopting a modal editing paradigm.


A demo of this mode is given below; you can see the keys pressed in the tab-line.
Feel free to extend and/or modify the key definitions to your liking.
You can check the value of =org-speed-commands= for inspiration.
#+caption: Demo of our org-motion state
[[file:~/Videos/meow-org-motion.gif]]
** Solving the Magic Square in Common Lisp :lisp:programming:
:PROPERTIES:
:EXPORT_HUGO_SECTION: comp
:EXPORT_FILE_NAME: magic-square-common-lisp
:END:
#+include: ~/programming/lisp-fun/magic-square.org
** Declarative Programming for Fast Brain-to-Binary
:PROPERTIES:
:EXPORT_HUGO_SECTION: comp
:EXPORT_FILE_NAME: brain_to_binary_bliss_of_decla_prog
:END:
Recently I've been messing around with different programming languages and branching out beyond the C-style languages I know like C++ and Python.
In my search for one to try out, I discovered Haskell, and the paradigm of functional programming as a whole.

As a mathematician by trade, the usefulness of programming was never lost on me.
From my time with C++ and Python, I had developed a (not unreasonable) notion that programming was all about telling computers how to do something you want done..
This changed when I learned of the functional programming paradigm, or more generally, declarative-style languages.

Suppose we wanted to write a function =fun= that takes in a non-negative integer and returns the sum of squares of numbers between 0 and that integer.
In fancy math language, the function would look like this:
\begin{align*}
\mathtt{fun} : \mathbf{Z}_{ \geqslant 0} &\to \mathbf{Z}_{\geqslant 0} \\
                                \mathtt{fun}(k)       &= \sum_{i=1}^k i^2.
\end{align*}

Let's implement this in Python with an imperative style of writing:
#+begin_src python
def fun(k):
    num = 0
    for i in range(k + 1):
        num += i**2
    return i
#+end_src
We're telling the computer here to step through all non-negative integers up to =k= and adding the square of these integers to a cumulative sum of all the previous numbers.
Perfectly intuitive and reasonable.

Let's implement this in Haskell, a more-or-less pure functional programming language with a highly expressive, declarative style of syntax:
#+begin_src haskell
fun k = sum [i*i | i <- [0..k]]
#+end_src
This solution is elegant once you know that the =<-= syntax is the set containment symbol \( \in \) from mathematics.

This declarative style of writing code is something I find myself coming back to whenever I want to quickly hack an idea together.
It lets me focus on implementing the key steps of the problem I have laid out, without getting bogged down with more minor details of how it should be solved.
Focusing on the /what/ and not the /how/ is a fast-track to getting a compiled program that does what you want it to do quickly.

Of course, this type of programming is not without faults.
For one, you are leaving the "how" up to compiler with how it implements the expressive syntax.
Compiler engineers and developers for the languages are a clever bunch, but if you want more fine-grain control, the imperative style is superior.

Another drawback to the declarative style is working on large projects with many developers.
Since declarative programs tend to read closer to natural language, it's possible that each developer will craft their own dialect within the confines of the syntax.
Having several people with several dialects working on a single project can be a challenge.
Oftentimes for the sake of team cohesion and ease of debugging, a unified style-guide for large projects is preferred.

Despite this, I will continue to prefer declarative programming for quick implementations, only moving to imperative when I think more control is needed.
** Emacs =org-mode= for LaTeX :emacs:org:hobby:productivity:
:PROPERTIES:
:EXPORT_HUGO_SECTION: comp
:EXPORT_FILE_NAME: emacs-to-type-LaTeX
:END:
About four years ago, my brother introduced me to Linux and free and open source software.
Around the same time I learned to use LaTeX to typeset documents with lots of mathematical notation.
I then stumbled across Gilles Castel's [[https://castel.dev/post/lecture-notes-1/][article on typing LaTeX with vim]], and I was amazed.

For those who don't know, typing LaTeX by default is a terrible experience.
/Terrible./
Using a program like vim with plugins made typing LaTeX so frictionless that I immediately dove into the world of extensible text editors.
I got more than I bargained for, but the payoff of effortless typesetting of math drove me to stick with it.
I finally replicated most of Castel's setup, and thought I had seen it all.

Then I found emacs org-mode.

#+begin_export hugo
<style>
aside {
    width: 40%;
    padding-left: 0.5rem;
    margin-left: 0.5rem;
    float: right;
    box-shadow: inset 5px 0 5px -5px #29627e;
    font-style: italic;
    color: #7a7c7d;
}

aside > p {
    margin: 0.5rem;
}
</style>
#+end_export
#+begin_aside
#+begin_quote
GNU Emacs [is] a sort of hybrid between Windows Notepad, a monolithic-kernel operating system, and the International Space Station.

---Steve Yegge
#+end_quote
#+end_aside
Vim, the program I had been using for easy LaTeX input, has had a longstanding "rivalry" with another editor called GNU Emacs.
Since spending time with both programs, I've found this "rivalry" a bit silly.
Vim and emacs are different programs designed with different use cases in mind with different philosophies.
They just /happen/ to both be text editors.
Comparing vim and emacs is a bit like comparing a bicycle to a tank simply because they can move people around quicker than by foot.

In any case, what brought me to emacs was org-mode.
Org-mode is a major mode of emacs, encompassing everything from marking up basic text files and exporting to PDF, keeping an agenda, and literally everything else you could imagine needing when it comes to typing documents of any sort.
Many think of it as souped-up markdown, but this is a disservice to its utility.
It's so powerful, I could probably find a way to make it do my laundry[fn:1].

What initially drove me to org-mode was the function =org-latex-preview=.
In contrast to vim, emacs is a graphical program, which allows the program to /display images of compiled LaTeX over the text buffer you're editing./
Let's see what that looks like.

Org-mode is plaintext, so the raw text file you're editing might look something like this.

#+begin_example
**Hermitian Metrics
We'd like an analogue of Riemannian manifolds but "complexified".
Recall that a metric \( g \) is a \( 2\times 2 \) symmetric matrix at a point.
The complex analogue of "symmetric" is Hermitian, which motivates the following definition:

*Definition:* A /Hermitian metric/ on a complex manifold with local coordinates \( (z^1,\ldots , z^m) \) is a tensor field
\begin{equation*}
h_{j \overline{k}} dz^j\otimes dz^{\overline{k}}
\end{equation*}
where \( h_{j \overline{k}} \) varies smoothly, and is positive definite and Hermitian at each point \( z \).
The form
\begin{equation*}
\omega = \frac{i}{2} h_{j \overline{k}} dz^j\wedge dz^{\overline{k}}
\end{equation*}
is called the /Kahler form/ of the metric.
A complex manifold with a Hermitian metric is called a /Hermitian manifold/.
#+end_example

Here is this same snippet of text, but viewed in emacs, with all the org goodies activated.
[[~/Pictures/website/org-latex-goodies-ex.png]]

Notice how the compiled LaTeX appears inline, and the font size is variable for the heading.
These inline LaTeX previews are what pulled me to org-mode, and with the help of some third party programs like =xenops-mode=[fn:2], these previews render asynchronously as I continue typing.

There are many moving parts to this puzzle, but videos speak louder than words, so here is a quick demo.
#+caption: Sped up 30%
[[~/Videos/emacs-math-demo.gif]]

I could write more about how I achieved this setup, but others that are much smarter than me already have.


[fn:1] My [[*My DOOM Emacs Configuration][DOOM Emacs Config]] is typed in org-mode thanks to its literate programming abilities. In fact, this entire website is just one big org-mode file.

[fn:2] With org version 9.7, =xenops-mode= will be wholly unnecessary thanks to a new default =org-latex-preview= function. See a demo [[https://www.youtube.com/watch?v=n-AfvuV-bYo&t=376s][here]].

** My DOOM Emacs Configuration :emacs:org:hobby:
:PROPERTIES:
:EXPORT_HUGO_SECTION: comp
:EXPORT_FILE_NAME: doom-config
:END:
#+attr_html: :class toc-class
#+begin_details
#+begin_summary
*Table of Contents*
#+end_summary
#+toc: headlines 2 local
#+end_details
#+include: ~/.doom.d/config.org
* Misc
:PROPERTIES:
:EXPORT_HUGO_SECTION: misc
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :type post
:END:
** Misc
:PROPERTIES:
:EXPORT_HUGO_SECTION: misc
:EXPORT_FILE_NAME: _index
:EXPORT_HUGO_MENU: :menu main
:END:
Some stuff that doesn't really fit anywhere else.
** DRAFT Managing Factor Tilts with the Portfolio Performance Program
*** Rebalancing
When maintaining a desired asset allocation in an investment portfolio, [[https://www.investopedia.com/terms/r/rebalancing.asp][rebalancing]] plays an important role.
Rebalancing is necessary to main a targeted asset allocation because different investment instruments perform differently over short periods of time.
Let's take a sample portfolio of $100 of two uncorrelated assets: equity and intermediate-term US treasuries.

Over the course of a year, our equity position might return 10%, while our bond position might only return 3%.
If we initially had our portfolio in  80% equity and 20% bonds, we would have \( \$80 \times 1.10= \$88 \) at the end of the year, and \( \$ 30\times 1.03= \$ 20.6 \) in bonds (assuming we reinvest distributions).
Our total portfolio value is now $108.6, but now our equity position makes up 81% of our portfolio, while bonds make up only ~19% of the portfolio.
This phenomenon is known as "drift".

If left unchecked, consistent differences in asset performance will cause drift to magnify, causing our portfolio to be more and more dominated by the higher-performing asset.
But we chose the 80/20 allocation on the basis of risk profile, and a drifting asset allocation alters the risk profile of the assets owned.
*Rebalancing* is the act of correcting the drift, and can accomplished by a mixture of two strategies: selling enough of the outperforming assets and reinvesting in the

** Astrophotos :astro:hobby:
:PROPERTIES:
:EXPORT_HUGO_SECTION: misc
:EXPORT_FILE_NAME: astrophotos
:END:
As a fairly new astrophotographer, these images will be quite poor to the discerning eye. Artifacts like dust spots, field curvature, and star trails can be seen in pretty much all of them, among many more artifacts. Regardless, I find a lot of satisfaction in this hobby as a fascinating blend of science and art.
*** M101: Pinwheel Galaxy
#+name: m101
#+caption: M101, The Pinwheel Galaxy
[[file:~/Pictures/astro/m101_take2.jpg][file:~/Pictures/astro/m101_take2.jpg]]
#+begin_details
#+begin_summary
Details
#+end_summary

It's been a while since I took this image, but I belive it total around 3 hours of integration
#+end_details
*** M42: The Orion Nebula
#+name: m42
#+caption: M42, The Orion Nebula
[[file:~/Pictures/astro/orion_phone_wallpaper.jpg][file:~/Pictures/astro/orion_phone_wallpaper.jpg]]
#+begin_details
#+begin_summary
Details
#+end_summary
This image was processed from my first ever outing doing astrophotography. It totals around 12 minutes of integration from the Bortle 1 sky around the McDonald Observatory. Weather prevented any more data collection, but I'm still surprised at how much I was able to get out of it. By contrast my [[*M101: Pinwheel Galaxy][image of M101]] was taken from a very light-polluted Bortle 8 sky, and that image was 3 hours of integration. This image always surprises me at how much better it is to image under dark skies.

The uneven illumination on the bottom left of the image is due to a strange reflection pattern on an IR cut filter I have for my camera. It's not present in other images because I imaged those without the filter.
#+end_details
** Some Theorems
:PROPERTIES:
:EXPORT_HUGO_SECTION: misc
:EXPORT_FILE_NAME: fav_theorems
:END:

#+begin_details
#+begin_summary
Table of Contents
#+end_summary
#+toc: headlines 1
#+end_details

*** Modular categories are not determined by their modular data
#+begin_details
#+begin_summary
A modular category \( \mathcal{C} \) is not determined by its \( S \) and \( T \) matrices.
#+end_summary

*Comments:* If something seems too good to be true, it probably is.
#+end_details
*** Classification of commutative Frobenius algebras by TQFTs
#+begin_details
#+begin_summary
For a field \( k \), there is an equivalence of categories \( \mathsf{2TQFT}_k \simeq \mathsf{cFrob}_k \) of 2-dimensional topological quantum field theories and commutative Frobenius algebras.
#+end_summary

*Comments:* This was the first result I learned that expressed how some classical tensor algebras arise as categorical constructions. Essential to this equivalence is the classification of closed 1-dimensional manifolds and how well behaved the category \( \mathsf{2Cob} \) is. A significant amount of work is needed to even hypothesize a higher dimensional analogue. This is the cobordism hypothesis, proposed by Baez and Dolan.
#+end_details
*** The Yoneda Lemma
#+begin_details
#+begin_summary
Let \( \mathsf{C} \) be a locally small category and \( F : \mathsf{C} \to \mathsf{Set} \) be a functor. Then
\[
\operatorname*{Hom}(\operatorname*{Hom}(X,-),F) \cong FX
\]
and this isomorphism is natural in both \(X\) and \(F\).
#+end_summary

*Comments:* This theorem is remarkable. The object on the left, as a collection of natural transformations, is seemingly incalculably large. Not only does this theorem tell us that this collection is a set, but it also gives an *explicit description* of these transformations, parameterized by \( FX \). When applied to \( F = \operatorname*{Hom}(Y,-) \) (or more generally representable functors), this theorem gives meaning to the intuitively-known idea that an object is uniquely determined by the maps into (our out of) it.
#+end_details
* 
:PROPERTIES:
:EXPORT_HUGO_SECTION: nihongo
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :type post
:END:
** 
:PROPERTIES:
:EXPORT_HUGO_SECTION: nihongo
:EXPORT_HUGO_MENU: :menu main
:EXPORT_FILE_NAME: _index
:END:



** 
:PROPERTIES:
:EXPORT_HUGO_SECTION: nihongo
:EXPORT_FILE_NAME: jojos_interesting_phrase
:END:
I came across the phrasein an episode of Jojo's Bizarre Adventure and couldn't help but smile at it.
The morphology of Japanese words is a fascinating one, and this sentence exemplifies it brilliantly.
Roughly, this sentence says "the ice is becoming ineffective", or more naturally, "the ice is becoming less effective".
The first word , is straightforward; it means "ice".
The particle  is an indicative particle meant to direct the attention of the listener to the noun it is attached to.

Now here comes the interesting part: the final .
The base of this phrase is , which means "to be effective, to function, to work".
From here, the verb is morphed to its negative .
Of course, this means "to not be effective".
One cool things about Japanese is that most words that end in morph like adjectives.
One such way adjective morph is by replacing the  with .
This morph is typically described as turning the adjective into an adverb, but the idea of turning a negative-conjugated verb into an adverb is a bit mysterious, especially since no such pattern exists in english.
Now we're left with .

Now that we have an "adverb", we need a verb for it to describe.
This is where comes in.
The entire last part is a morph of this verb, which means "to become".
 becomes , which is a special morph (called -te form) of verbs that can set up a number of new morphs.
From here we add the verb , which means "to come to be".
From  we then turn the  into /its/ -te form, yielding .
(It's worth nothing that this construction is usually written in kana, hence I drop the kanji.)
The final addition is the verb .
When this verb is added to the -te form of another verb, it expresses an enduring state of action.
Oftentimes this translated to the present progressive form in english, e.g. run -> /running/.

So we're left with , which roughly means "is becoming".
The nuance of the  is sadly lost since there is no real way to directly translate this to english.

When I first heard this sentence it took me some seconds to parse.
As an english native speaker, I'm not used to having to listen this long to a single phrase to glean its meaning.
Let's take a different approach to illustrate how long words can be constructed.

Remember the  adjective morphs I mentioned?
It turns out that the negative of an  adjective is also an  adjective!
As such, there is theoretically *no upper bound to how long of a "word" you can grammatically correctly construct in Japanese*.

The construction is simple: take an  adjective and negate it.
The way to do this is change the final  to .
Repeat.
For example with the word , meaning "good", we can negate it twice to the word meaning "not not good":
#+begin_example
 >  > 
#+end_example
But the final word here is also an  adjective.
This means that this is also a grammatically correct construction:
#+begin_example

#+end_example
Repeat as needed to construct as long of a word as you want.
Of course, we've long left the issue of pragmatism behind, but still, it's pretty not not not not not not not not not not not not not not not not cool, huh?

