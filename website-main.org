#+hugo_base_dir: /home/aatmun/websites/site/
#+hugo_weight: auto
#+bibliography: ~/Documents/bib/reference-articles.bib
#+options: ':t todo:nil date:t
#+cite_export: csl
#+startup: logdone


* Home
:PROPERTIES:
:EXPORT_HUGO_SECTION:
:EXPORT_HUGO_FRONT_MATTER: :toc false :author false
:EXPORT_FILE_NAME: _index
:EXPORT_HUGO_WEIGHT: -10
:END:
** About Me
:PROPERTIES:
:EXPORT_HUGO_SECTION:
:EXPORT_HUGO_MENU: :menu main
:END:
I am a PhD student in mathematics at Texas A&M University.

- *Advisor*: [[https://people.tamu.edu/~rowell/][Dr. Eric Rowell]]
- *Research interests:* (\( G \)-crossed) braided fusion categories and fusion categories.
*** Education
- PhD Mathematics, Texas A&M University (in progress)
- MS Mathematics, Texas A&M University 2023
- BS Mathematics, UCLA 2021
*** Hobbies
- Programming. I'm currently working in Rust, Common Lisp, and Python.
- Liverpool FC
- Astrophotography. Check my images [[*Astrophotos][here]]
- Learning japanese through immersion
- Free (as in freedom) software
  - This site is deployed with the [[https://github.com/kaushalmodi/ox-hugo][ox-hugo]] program in GNU emacs
** Contact
- *Email*: [[mailto:abaxi@tamu.edu][abaxi@tamu.edu]]
- *Office*: Blocker 506B
* Math
:PROPERTIES:
:EXPORT_HUGO_SECTION: math
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :type post
:END:
** Math
:PROPERTIES:
:EXPORT_HUGO_SECTION: math
:EXPORT_FILE_NAME: _index
:EXPORT_HUGO_MENU: :menu main
:END:
Here I keep some thoughts about math-related things I find interesting or worth sharing.
** Realizing some Multiplicity-Free Fusion Rules :categories:
:PROPERTIES:
:EXPORT_HUGO_SECTION: math
:EXPORT_FILE_NAME: realizing_fusion_rules
:EXPORT_OPTIONS: toc:nil
:END:
/Disclaimer: These results have not been subjected to the rigors of publication./
*** Fusion Rings
Classifying fusion categories is a huge task--likely impossible--but much effort has been made to find certain invariants to help distinguish fusion categories at various levels of structure.
One such invariant is the *fusion ring* associated to a fusion category \( \mathcal{C} \).
They are one of the more useful invariants of fusion categories, though they are incomplete at determining the whole structure of the category.
For instance, one area they fall short is the lack of their ability to capture the associativity isomorphism \( (X \otimes Y) \otimes Z\cong X \otimes (Y \otimes Z) \) and in certain cases the braiding \( X \otimes Y \cong Y \otimes X \).

**** The Fusion Ring of a Fusion Category
Recall that fusion categories are rigid, semisimple, abelian, \( k \)-linear, monoidal categories with finitely many simple objects, which include the monoidal unit \( \mathbf{1} \).
Let \( \mathcal{C} \) be a fusion category and denote the collection of simple objects by \( \mathcal{O}( \mathcal{C} )  = \left\{ X_0 , \ldots , X_n \right\} \) in an ordered fashion, choosing \( X_0 = \mathbf{1} \).
The direct sum on objects in a fusion (in fact, just abelian \( k \)-linear) category act as an "addition".
We can formalize this with the *Grothendieck group*: the free abelian group generated by the set \( \mathcal{O}( \mathcal{C} ) \), considered with equality up to isomorphism.

Continuing in the same way, the tensor product induces a kind of "multiplication" on the objects of \( \mathcal{C} \).
i.e., we have a multiplication structure on the Grothendieck group given by
\begin{equation}
\label{eq:2}
X_i\cdot X_{j} = [X_i \otimes X_j]
\end{equation}
where \( [X_i \otimes X_j] \) denotes the isomorphism class of the object \( X_i \otimes  X_j \).
The ring with this multiplication and addition is called the *Grothendieck ring* of the category \( \mathcal{C} \).

Notice that everything we've said so far doesn't use some key properties of fusion categories.
To start with, semisimplicity tells us that \( X_i \otimes X_j \) is a finite direct sum of the simple objects \( X_i \).
The general description of the isomorphism class of this object is then
#+name: fusion-decomp
\begin{equation}
\label{eq:fusion-decomp}
X_i \otimes X_j \cong \bigoplus_{k=1}^{n} N_{ij}^k X_k
\end{equation}
where \( N_{ij} \) are non-negative integers called the *fusion rules*.
The various structures above assemble a special kind of ring called a *fusion ring*.
A fusion ring is a unital based ring of finite rank.
We unroll the definitions:
#+begin_center
A based ring \( R \) is a ring that is free as a \( \mathbf{Z} \)-module equipped with the following:

a. <<structure-coeffs>> A \( \mathbf{Z}_+ \)-basis \( B = \left\{ b_i \right\}_{i\in I} \) such that \( b_i b_j = \sum_{k\in I}^{} c_{ij}^kb_k \) where \( c_{ij}^k\in \mathbf{Z}_+ \).
b. And identity \( 1 \) which is a non-negative linear combination of the basis
c. Let \( \tau : R \to \mathbf{Z} \) be the group homomorphism taking \( b_i \) to \( 1 \) if \( b_i \) appears in the decomposition of \( \mathbf{1} \), and \( 0 \) otherwise.
   We demand that there is an involution \( i \mapsto i^{*} \) of the ring such that the induced ring endomorphism is an anti-involution and the map \( \tau \) satisfies \( \tau(b_i b_j) =1 \) if \( i = j^{*} \) and \( 0 \) otherwise.

A based ring is called /unital/ if the identity \( 1 \) is a basis element.
We conclude by noting that /finite rank/ means there are finitely many basis elements.
#+end_center

The constraint in a is analogous to the fusion decomposition, while the involution in c comes from the rigidity of the category.
More details and standard results can be found in [[cite:&etingofTensorCategories2016 Chapter 3]].
*** Fusion Rings as an Invariant of Fusion Categories
To every fusion category we can associated a fusion ring.
Many questions in math come from asking about the opposite of a process we know we can carry out.
In this case, we can ask about the /categorifiability/ of a fusion ring.
That is, /given a fusion ring \( R \), can we construct a fusion category whose Grothendieck ring is \( R \)?/
One might even ask for more and ask if we can /uniquely/ construct a fusion category from a given fusion ring.

The answer to the latter is a definitive /no/.
One can construct two inequivalent fusion categories which descend to isomorphic fusion rings.
Not all hope is lost though, the theorem /Ocneanu rigidity/ states that there a finitely many equivalence classes of fusion categories with a given fusion ring.
The question of if there are finitely many fusion categories of any given rank is very much open.

To my knowledge, the question of categorifiability of a fusion ring has only a partial answer.
Namely, one can rule out categorifiability and unitary categorifiability via some properties of the fusion coefficients (see [[cite:&vercleyenLowRankFusion2023]]), but there is not a complete criteria of categorifiability of fusion rings.
*** Low Rank Fusion Rings
The benefit of working from fusion rings up to fusion categories is that fusion rings are highly computable (at least in comparison to fusion categories).
The authors [[cite:&vercleyenLowRankFusion2023]] used a computer algebra system to compute some fusion rings through rank \( 9 \).
They published a list of explicity known fusion rules along with some known (or conjectured) properties on the website [[https://anyonwiki.github.io/]].
You'll notice that some of the fusion rings have unknown properties, like whether or not they are categorifiable.
I set out to work on some of those properties.
*** Fusion Rules \( \operatorname{FR}^{8,0}_4 \)
The fusion rules \( \operatorname{FR}^{8,0}_4 \) (https://anyonwiki.github.io/pages/FRPages/FR_8_1_0_4.html) arise from  a rank \( 8 \) fusion ring which is multiplicity-free.
Here, multiplicity-free means that the fusion rules are either \( 0 \) or \( 1 \).
Up to now it was unknown if this ring was categorifiable, and I answered this question positively.

It was pointed out to me by my advisor that a good place to look for a categorification was a subcategory of the so-called metaplectic categories \( \operatorname{SO}(N)_2 \).
The details of these categories are beyond the scope of the article, but their fusion rules are known completely [[cite:&bruillardDimensionQuantumStatistic2018;&ardonneClassificationMetaplecticModular2016;&gustafsonMetaplecticCategoriesGauging2018]].

We can realize the fusion rules \( \operatorname{FR}^{8,0}_4 \) as "one half" of the metaplectic category \( \operatorname{SO}(12)_2 \).
We say "one half", because the category \( \operatorname{SO}(12)_2 \) is graded by the group \( \mathbf{Z}_{2} \times \mathbf{Z}_{2} \), and we can choose the fusion category generated by the trivial graded component and the graded component associated to \( (1,0) \) (or equivalently, \( (0,1) \)).

One can use the results of [[cite:&bruillardDimensionQuantumStatistic2018]] to compute the complete set of fusion rules of the objects of \( \operatorname{SO}(12)_2 \) chosen accordingly.
A summary of the results of this computation are presented in the tables below.
Compare these results to the fusion rules presented on the [[https://anyonwiki.github.io/pages/FRPages/FR_8_1_0_4.html][AnyonWiki]].

For an example of one such computation, we work out \( X_1 \otimes V_1 \).
The multiplicity of any simple object in the direct sum decomposition can be found using the Frobenius reciprocity laws.
That is, for simple objects \( A,B,C \), \( N_{A,B}^C = N_{A^{*},C}^B = N_{C, B^{*}}^A \).

The multiplicity of \( X_i \) in the decomposition of \( X_1 \otimes  V_1 \) is given by \( N_{X_1, V_1}^{X_i} = N_{X_1^{*} , X_i}^{V_1} = N_{X_1 , X_i}^{V_1} = 0 \) by self-duality of simple objects.
A simple object \( X \) is self-dual if \( N_{X,X}^{\mathbf{1}}\neq 0 \).
i.e. that \( \mathbf{1} \) appears in the direct sum decomposition of \( X \otimes X \).
Similarly, \( N_{X_1 , V_1}^f = N_{X_1 ,f}^{V_1} = 0 \) and similarly for the multiplicity of \( g,fg \).
Finally, \( N_{X_1 , V_1}^{V_1} = N_{V_1 , V_1}^{X_1}= 1 \) and similarly for \( N_{X_1 , V_1}^{V_2}=1 \).

#+name: one_half_so_12_dimension
#+caption: Dimensions of simple objects in "one half" \( \operatorname{SO}(12)_2 \)
| Object    | Dimension      |
|-----------+----------------|
| *1*         | \( 1 \)        |
| \( g \)   | \( 1 \)        |
| \( f \)   | \( 1 \)        |
| \( fg \)  | \( 1 \)        |
| \( X_0 \) | \( 2 \)        |
| \( X_1 \) | \( 2 \)        |
| \( V_1 \) | \( \sqrt{6} \) |
| \( V_2 \) | \( \sqrt{6} \) |


#+caption: Fusion rules for "one half" \( \operatorname{SO}(12)_2 \)
#+name: one_half_so12_fusion_rules
| Object           | \( \mathbf{1} \) | \( f \)          | \( g \)          | \( fg \)         | \( X_0 \)                          | \( X_1 \)                           | \( V_1 \)                                         | \( V_2 \)                                           |
|------------------+------------------+------------------+------------------+------------------+------------------------------------+-------------------------------------+---------------------------------------------------+-----------------------------------------------------|
| \( \mathbf{1} \) | \( \mathbf{1} \) | \( f \)          | \( g \)          | \( fg \)         | \( X_{0} \)                        | \( X_{1} \)                         | \( V_{1} \)                                       | \( V_{2} \)                                         |
| \( f \)          | --               | \( \mathbf{1} \) | \( fg \)         | \( g \)          | \( X_1 \)                          | \( X_0 \)                           | \( V_1 \)                                         | \( V_{2} \)                                         |
| \( g \)          | --               | --               | \( \mathbf{1} \) | \( f \)          | \( X_1 \)                          | \( X_0 \)                           | \( V_2 \)                                         | \( V_{1} \)                                         |
| \( fg \)         | --               | --               | --               | \( \mathbf{1} \) | \( X_0 \)                          | \( X_1 \)                           | \( V_2 \)                                         | \( V_1 \)                                           |
| \( X_{0} \)      | --               | --               | --               | --               | \(\mathbf{1}\oplus fg \oplus X_1\) | \( f\oplus g\oplus fg \oplus X_0 \) | \( V_{1} \oplus V_2 \)                            | \( V_{1} \oplus V_1 \)                              |
| \( X_{1} \)      | --               | --               | --               | --               | --                                 | \(\mathbf{1} \oplus fg \oplus X_1\) | \( V_{1} \oplus V_2 \)                            | \( V_{1} \oplus V_2 \)                              |
| \( V_{1} \)      | --               | --               | --               | --               | --                                 | --                                  | \( \mathbf{1}\oplus f \oplus X_{0}\oplus X_{1} \) | \( f \oplus fg \oplus X_{0} \oplus X_{1} \)         |
| \( V_{2} \)      | --               | --               | --               | --               | --                                 | --                                  | --                                                | \( \mathbf{1} \oplus f \oplus X_{0} \oplus X_{1} \) |
*** Fusion Rules \( \operatorname{FR}^{9,0}_{7} \)
It turns out that a categorification of the fusion rules \( \operatorname{FR}^{9,0}_7 \) (https://anyonwiki.github.io/pages/FRPages/FR_9_1_0_7.html) is nearly identical to that of \( \operatorname{FR}^{8,0}_4 \), just with a different choice of metaplectic category.
In this instance, we choose "one half" of \( \operatorname{SO}(16)_2 \) using the exact same method to choose generating objects.
The results are summarized in the tables below.

#+name: one_half_so_16_dimension
#+caption: Dimensions of simple objects in "one half" \(\operatorname{SO}(12)_2 \)
| Object    | Dimension                   |
|-----------+-----------------------------|
| *1*         | \( 1 \)                     |
| \( g \)   | \( 1 \)                     |
| \( f \)   | \( 1 \)                     |
| \( fg \)  | \( 1 \)                     |
| \( X_0 \) | \( 2 \)                     |
| \( X_1 \) | \( 2 \)                     |
| \( X_2 \) | \( 2 \)                     |
| \( V_1 \) | \(2 \sqrt{2}\)              |
| \( V_2 \) | \(2 \sqrt[\phantom{a}]{2}\) |

#+name: one_half_so16_fusion_rules
#+caption: Fusion rules for "one half" \( \operatorname{SO}(16)_2 \)
|                  | \( \mathbf{1} \) | \( f \)          | \( g \)          | \( fg \)         | \( X_0 \)                          | \( X_1 \)                                  | \( X_2 \)                             | \( V_1 \)                                                   | \( V_2 \)                                                      |
|------------------+------------------+------------------+------------------+------------------+------------------------------------+--------------------------------------------+---------------------------------------+-------------------------------------------------------------+----------------------------------------------------------------|
| \( \mathbf{1} \) | \( \mathbf{1} \) | \( f \)          | \( g \)          | \( fg \)         | \( X_{2} \)                        | \( X_{1} \)                                | \( X_2 \)                             | \( V_{1} \)                                                 | \( V_{2} \)                                                    |
| \( f \)          | --               | \( \mathbf{1} \) | \( fg \)         | \( g \)          | \( X_2 \)                          | \( X_1 \)                                  | \( X_0 \)                             | \( V_1 \)                                                   | \( V_{2} \)                                                    |
| \( g \)          | --               | --               | \( \mathbf{1} \) | \( f \)          | \( X_2 \)                          | \( X_1 \)                                  | \( X_0 \)                             | \( V_2 \)                                                   | \( V_{1} \)                                                    |
| \( fg \)         | --               | --               | --               | \( \mathbf{1} \) | \( X_0 \)                          | \( X_1 \)                                  | \( X_2 \)                             | \( V_2 \)                                                   | \( V_1 \)                                                      |
| \( X_{0} \)      | --               | --               | --               | --               | \(\mathbf{1}\oplus fg \oplus X_1\) | \(X_0\oplus X_2\)                          | \(f \oplus g \oplus X_1\)             | \( V_{1} \oplus V_2 \)                                      | \( V_{1} \oplus V_2 \)                                         |
| \( X_{1} \)      | --               | --               | --               | --               | --                                 | \(\mathbf{1} \oplus f \oplus g \oplus fg\) | \(X_0\oplus X_2\)                     | \( V_{1} \oplus V_2 \)                                      | \( V_{1} \oplus V_2 \)                                         |
| \( X_{2} \)      | --               | --               | --               | --               | --                                 | --                                         | \( \mathbf{1} \oplus fg \oplus X_1 \) | \( V_{1} \oplus V_2 \)                                      | \( V_{1} \oplus V_2 \)                                         |
| \( V_{1} \)      | --               | --               | --               | --               | --                                 | --                                         | --                                    | \( \mathbf{1}\oplus f \oplus X_{0}\oplus X_{1}\oplus X_2 \) | \( f \oplus fg \oplus X_{0} \oplus X_{1} \)                    |
| \( V_{2} \)      | --               | --               | --               | --               | --                                 | --                                         | --                                    | --                                                          | \( \mathbf{1} \oplus f \oplus X_{0} \oplus X_{1} \oplus X_2 \) |

*** Bibliography
[[bibliography:~/Documents/bib/zotero_refs.bib]]
** Quantum Computing, Braids, and Modular Categories :math:categories:
:PROPERTIES:
:EXPORT_HUGO_SECTION: math
:EXPORT_FILE_NAME: quantum_comp_and_modular_categories
:END:

*** Introduction
Quantum computing (QC) is an exciting new paradigm of computation, promising exponential speedup from state-of-the-art classical algorithms in certain computing tasks.
Despite vigorous research from all sides of the task, obstacles to a quantum computer architecture that is scalable and tolerant to errors remain hard to overcome.

Qubits in existing models of quantum computation (such as trapped-ion models) are sensitive to their environment.
Such sensitivities of the environment make qubits liable to introducing noise that dominates the computation we'd like to measure.
To ensure we can recover usable data, we'd (approximately) need on the order of thousands of physical qubits per logical qubit to near-guarantee our computation is correct.
This would be no issue if current QC implementations were highly scalable, but they are not.
Topological quantum computing is a theoretical basis to address both these issues simultaneously.

*** Anyons and their statistics
While traditional QC implementations use bosons and fermions for qubits, topological quantum computing (TQC) uses /anyons/.
Recall that two bosons exchange in a wave function causing a global phase shift \( +1 \) (i.e. \( | \varphi_1 \varphi_2 \rangle = | \varphi_2 \varphi_1 \rangle\)).
Conversely, fermions exchange with a global phase shift \( -1 \), so \( | \varphi_1 \varphi_2 \rangle = - | \varphi_2 \varphi_1 \rangle \).
Anyons are type of quasiparticle that allow for more general phase shifts \( e^{i\theta} \) for some value of \( \theta \).
We recover bosons and fermions at \( \theta= 0 \) and \( \theta=\pi \), respectively.
Anyons can take any statistics between Bose-Einstein statistics and Fermi-Dirac statistics and beyond, corresponding to values \( 0 \leqslant \theta \leqslant 2\pi \).

I've somewhat lied by omission in the previous paragraph.
The global phase shifts corresponding to \( e^{i\theta} \) are actually relevant to the so-called /abelian anyons/.
One can generalize this phase shift further to an even larger class of unitary operators satisfying the [[https://en.wikipedia.org/wiki/Yang%E2%80%93Baxter_equation][Yang-Baxter equation]]; such quasiparticles are /non-abelian anyons/.
These non-abelian anyons are the building blocks to encoding information in TQC.
The question remains--/what does this buy us?/
I've already alluded to how TQC may be less sensitive to environmental noise than classical qubits, so we should understand how.

#+name: anyonexchange
#+caption: Inequivalent exchanges for identical anyons.
#+attr_html: :width 150%
[[file:figures/anyon_exchange.svg]]

When thinking about how anyons interact with each other, we must think topologically.
That is, we can do everything up to a "smooth/continuous" deformation.
In one dimension of space, nothing interesting can happen: we cannot exchange anyons at all.
In three dimensions of space, everything is trivial.
If an anyon moves around another anyon back to its starting position, one can "drag" the path and shrink it simultaneously, so that topologically the path is indistinguishable from the particle not moving at all.

In two dimensions of space, things get more interesting.
In a flatland with two particles, there are two topologically distinct paths a particle can take in the plane.
They are illustrated in Figure [[anyonexchange]].
In fact, there are infinitely many: one can wind a particle around the other as many times as needed to produce a path distinct from the others.
#+name: braids
#+caption: Braids on n=3 strands traced out over time progression.
#+attr_html:  :width 150%
[[file:figures/braids.png]]

At each slice of time, the position of anyons in flatland correspond to points in a plane.
As we progress time, the trajectories of the anyons trace out paths akin to strands of string.
The strings cannot cross through each other, as this would mean the particles "collide" at some point in time.
Figure [[braids]] illustrates this phenomenon, with the arrow indicating the passage of time.

Mathematically, the collection of all these trajectories for some fixed \( n \) particles--disallowing the strands doubling back--form a group under composition: it is the *braid group on \( n \) strands*, denoted \( \mathcal{B}_n \).
Here, the braid group is an instance of a more general kind of group called a *motion group*.
The mathematical formulation of this is to say that the braid group on \( n \) strands is the motion group of a disjoint union of points embedded in a compact box.
More general motion groups corresponding exist, such as motions of circles or trefoils in a compact box.
These are quite a bit more complicated, and we know little about them compared to the braid groups.

To each braiding we want to associate a unitary operator (read: a quantum gate), so we can say that mathematically, the statistics of \( n \) anyons correspond to certain unitary representations \( \mathcal{B}_n \to U(V) \) of the braid group on \( n \) strands.
From a practical perspective, the act of applying a quantum gate to a system of anyons would correspond to braiding them.
This basis for computing is intuitively less sensitive to environmental noise in the sense that the topological properties of braids are more stable under small perturbation.
One can imagine that it is easier for a ball to bump into a wall from a slight gust of wind than to rearrange two crossed strings so that the lower string lies on top by cutting and rearranging.
This comparison is not unlike the difference between the sensitivity of qubits in the classical QC world and the TQC world.
Study of braid groups, motion groups, and the unitary representations of these groups shed light on the behavior of anyons, making it a subject of physical interest, and not just one of intrinsic beauty.

*** Modular Categories
We switch gears a bit to discuss the other data of anyon systems, of which there is many.
The study of braids and their unitary representations will capture how the interactions of anyons in space alter the data of the global quantum system, but says nothing of the data internal to the particles, and how that data changes.

Anyons carry lots of intrinsic data.
One can formalize the physics of anyons along with certain symmetries and stabilities and collect them into a set of equations to solve for.
Kitaev [[cite: &kitaevAnyonsExactlySolved2006 Appendix E]] suggested that the algebraic combinatorics of the solutions to these equations can be formalized in the language of *unitary modular categories*.

The language of categories came about much earlier as a language of formalize analogous phenomena that occur in seemingly unrelated areas of mathematics.
Recently, categories enriched with extra structure have been studied due to their flexibility in encoding certain data.
Technically speaking, modular categories arose from the study of conformal field theories, which are a kind of quantum field theory that exhibit certain topological invariances.

The definition of a modular category is a bit complex; it is a ribbon fusion category with nondegenerate \( S \)-matrix.
The interested reader can refer to Figure [[fig:modular_definition_tree]] for a tree of what each of these terms imply.
Each property/structure is interesting in its own right.

#+name: fig:modular_definition_tree
#+begin_src plantuml :file figures/modular_tree.png :results file
@startmindmap modularmap
skinparam backgroundColor transparent
,*[#LightGray] modular
,**[#LightGray] ribbon
,***[#LightGray] braided
,***[#LightGray] twist compatible with duals
,**[#LightGray] fusion
,***[#LightGray] rigid
,***[#LightGray] semisimple
,***[#LightGray] abelian
,***[#LightGray] k-linear
,***[#LightGray] monoidal
,***[#LightGray] finitely many simple objects including unit
,**[#LightGray] nondegenerate S-matrix
,***[#LightGray] unit object is the only transparent object
@endmindmap
#+end_src
#+caption: Definition of monoidal category and what each term means. Moving to the right means "has this property".
#+RESULTS: fig:modular_definition_tree
[[file:figures/modular_tree.png]]



The reader might ask if the "braided" in Figure [[fig:modular_definition_tree]] is related to the braiding discussed for anyons.
Indeed it is, the braiding in a unitary modular category corresponds to braiding of anyons.
There is an comprehensive dictionary of the correspondence between unitary modular categories and the physical interpretation of what the data represent.
[[cite:A more detailed dictionary is found in;&rowellMathematicsTopologicalQuantum2018;Table 1]].

#+begin_export hugo
<style>
sane-table#table {
    margin-left: auto;
    margin-right: auto;

}
sane-table table {
  border-collapse: collapse;
  width: 100%;
  margin-left: auto;
  margin-right: auto;
}
.sane-table th,
.sane-table td {
  padding: 0.25rem;
  text-align: left;
  border: 1px solid #ccc;
  margin-left: auto;
  margin-right: auto;
}
</style>
#+end_export
#+name: anyon_dictionary
#+attr_html: :class sane-table :align center
#+caption: Synonyms from the worlds of unitary modular categories and anyon systems
| Unitary Modular Category | Anyon System     |
|--------------------------+------------------|
| Simple object            | Anyon            |
| Tensor product           | Fusion           |
| Dual object              | Antiparticle     |
| Evaluation               | Annihilation     |
| Coevaluation             | Creation         |
| Unit object              | Vacuum Sector    |
| Twist                    | Topological Spin |

Classifying unitary modular categories up to some notion of equivalence is therefore equivalent to classifying systems of anyons.
This is a difficult problem, but is thought to be possible, and positive signs have appeared.
It was shown in [[cite:&bruillardRankfinitenessModularCategories2016]] that there are only finitely many modular categories for a given rank.
Physically, this would mean that a system \( n \) anyons can only interact nontrivially in finitely many distinct ways for each amount \( n \).

The ergonomics of modular categories can be challenging given the sheer number of equations to solve, but down-to-earth examples exist.
Perhaps the most well known is \( \mathsf{Vec} \), the category of finite dimensional vector spaces.
This is a rank \( 1 \) modular category with \( S \)-matrix \( (1) \) and \( T \)-matrix \( (1) \).
Ok, not very interesting...
This is indeed the most trivial example of a modular category, though more examples exist that are only slightly more difficult to understand.
For example, the category of metric groups \( (G,q) \) is equivalent to the category of pointed modular categories.
[[cite:see &etingofTensorCategories2016 chap 8]].

Despite the difficulty of classifying modular categories, this task enjoys deep connections to representation theory, quantum field theory, and condensed matter physics.
*** Conclusion
TQC is an exciting field gaining more and more traction as the years go by.
Experimental evidence for topological matter with gapped phases earned Thouless, Kosterlitz, and Haldane the Nobel Prize in Physics in 2016.
Microsoft has staked its entire quantum computing research division on the premise of TQC.
The study of modular categories is advancing at rapid pace, and we are learning more and more about representation theory and quantum algebra along the way.
*** Bibliography
[[bibliography:~/Documents/bib/zotero_refs.bib]]

*** Notes :noexport:
- quantum computing is not fault tolerant, based on physical limitations and introductions of noise in trapped quantum systems
- modular effectively model systems of anyon quasiparticles, the main ingredient to TQC (Kitaev)
- TQC allows for scalable fault-tolerant QC, where the error correction is performaed at the hardware level
  - This is perhaps its strongest merit
** DRAFT A "Yoga" to Realizing Multiplicity-Free Fusion Rules :math:categories:
Since writing about [[*Realizing some Multiplicity-Free Fusion Rules][realizing multiplicity-free fusion rules]], I've gone through more of the [[https://anyonwiki.github.io/][AnyonWiki]] database and realized more fusion rules, picking up some techniques to hint at possible answers along the way.
I hesitate to call this a yoga (whatever that means, anyway), because really it's just a set of heuristics following the information provided.

Before discussing the heuristics and how they might apply, let's go over some information provided by the AnyonWiki (AW) about the computed fusion rings.

*** Numerical Data for Fusion Rings
There are two basic types of numerical data for fusion rings: the rank and the Frobenius-Perron (or "quantum") dimensions.
The rank is simple: it is the number of \( \mathbf{Z}_+ \)-basis elements of the ring.
Due to computational intractability, the AW lists only mutliplicity-free fusion rings of rank 1-9.

The second numerical data associated to a fusion ring is the Frobenius-Perron (FP) dimension.
Not only is the ring assigned an FP dimension, but the basis elements are assigned one too.
Dimensions can thus provie discriminatory power between two fusion rules of the same rank.

Despite the similarities in behavior between fusion categories and \( \mathsf{Vec} \), the category of finite dimension vector spaces, FP dims can be more general than the familiar dimensions of vector spaces.
For example, the [[https://anyonwiki.github.io/pages/FRPages/FR_2_1_0_2.html][Fibonacci category]] has a simple object of dimension \( \phi \), the golden ratio.
A higher rank example of Frobenius-Perron dimensions for basis elements is presented in Table

|               Particle | Numeric |     Symbolic |
|------------------------+---------+--------------|
|                      1 |      1. |            1 |
|                      2 |      1. |            1 |
|                      3 |      1. |            1 |
|                      4 |      1. |            1 |
|                      5 |      2. |            2 |
|                      6 |      2. |            2 |
|                      7 | 2.44949 | \(\sqrt{6}\) |
|                      8 | 2.44949 | \(\sqrt{6}\) |
| \(\mathcal{D}_{FP}^2\) |     24. |           24 |



** LAWRGe 2023 Notes :math:conference:notes:
:PROPERTIES:
:EXPORT_HUGO_SECTION: math
:EXPORT_FILE_NAME: LAWRGe_2023_notes
:END:
#+toc: headlines 2 local
#+include: "~/Documents/org/notes.org::*LAWRGe Workshop"
* Computing
:PROPERTIES:
:EXPORT_HUGO_SECTION: computing
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :type post
:END:
** Computing
:PROPERTIES:
:EXPORT_HUGO_SECTION: computing
:EXPORT_FILE_NAME: _index
:EXPORT_HUGO_MENU: :menu main
:END:
I've spent a lot of time developing a workflow that works well for me, mainly centered around my time typesetting math, and finding better ways to do so.
Here I record some things that I've learned along the way.
** Solving the Magic Square in Common Lisp :lisp:programming:
:PROPERTIES:
:EXPORT_HUGO_SECTION: computing
:EXPORT_FILE_NAME: magic-square-common-lisp
:END:
#+include: ~/programming/lisp-fun/magic-square.org
** Declarative Programming for Fast Brain-to-Binary
:PROPERTIES:
:EXPORT_HUGO_SECTION: computing
:EXPORT_FILE_NAME: brain_to_binary_bliss_of_decla_prog
:END:
Recently I've been messing around with different programming languages and branching out beyond the C-style languages I know like C++ and Python.
In my search for one to try out, I discovered Haskell, and the paradigm of functional programming as a whole.

As a mathematician by trade, the usefulness of programming was never lost on me.
From my time with C++ and Python, I had developed a (not unreasonable) notion that programming was all about telling computers how to do something you want done..
This changed when I learned of the functional programming paradigm, or more generally, declarative-style languages.

Suppose we wanted to write a function =fun= that takes in a non-negative integer and returns the sum of squares of numbers between 0 and that integer.
In fancy math language, the function would look like this:
\begin{align*}
\mathtt{fun} : \mathbf{Z}_{ \geqslant 0} &\to \mathbf{Z}_{\geqslant 0} \\
                                \mathtt{fun}(k)       &= \sum_{i=1}^k i^2.
\end{align*}

Let's implement this in Python with an imperative style of writing:
#+begin_src python
def fun(k):
    num = 0
    for i in range(k + 1):
        num += i**2
    return i
#+end_src
We're telling the computer here to step through all non-negative integers up to =k= and adding the square of these integers to a cumulative sum of all the previous numbers.
Perfectly intuitive and reasonable.

Let's implement this in Haskell, a more-or-less pure functional programming language with a highly expressive, declarative style of syntax:
#+begin_src haskell
fun k = sum [i*i | i <- [0..k]]
#+end_src
This solution is elegant once you know that the =<-= syntax is the set containment symbol \( \in \) from mathematics.

This declarative style of writing code is something I find myself coming back to whenever I want to quickly hack an idea together.
It lets me focus on implementing the key steps of the problem I have laid out, without getting bogged down with more minor details of how it should be solved.
Focusing on the /what/ and not the /how/ is a fast-track to getting a compiled program that does what you want it to do quickly.

Of course, this type of programming is not without faults.
For one, you are leaving the "how" up to compiler with how it implements the expressive syntax.
Compiler engineers and developers for the languages are a clever bunch, but if you want more fine-grain control, the imperative style is superior.

Another drawback to the declarative style is working on large projects with many developers.
Since declarative programs tend to read closer to natural language, it's possible that each developer will craft their own dialect within the confines of the syntax.
Having several people with several dialects working on a single project can be a challenge.
Oftentimes for the sake of team cohesion and ease of debugging, a unified style-guide for large projects is preferred.

Despite this, I will continue to prefer declarative programming for quick implementations, only moving to imperative when I think more control is needed.
** Emacs =org-mode= for LaTeX :emacs:org:hobby:productivity:
:PROPERTIES:
:EXPORT_HUGO_SECTION: computing
:EXPORT_FILE_NAME: emacs-to-type-LaTeX
:END:
About four years ago, my brother introduced me to Linux and free and open source software.
Around the same time I learned to use LaTeX to typeset documents with lots of mathematical notation.
I then stumbled across Gilles Castel's [[https://castel.dev/post/lecture-notes-1/][article on typing LaTeX with vim]], and I was amazed.

For those who don't know, typing LaTeX by default is a terrible experience.
/Terrible./
Using a program like vim with plugins made typing LaTeX so frictionless that I immediately dove into the world of extensible text editors.
I got more than I bargained for, but the payoff of effortless typesetting of math drove me to stick with it.
I finally replicated most of Castel's setup, and thought I had seen it all.

Then I found emacs org-mode.

#+begin_export hugo
<style>
aside {
    width: 40%;
    padding-left: 0.5rem;
    margin-left: 0.5rem;
    float: right;
    box-shadow: inset 5px 0 5px -5px #29627e;
    font-style: italic;
    color: #7a7c7d;
}

aside > p {
    margin: 0.5rem;
}
</style>
#+end_export
#+begin_aside
#+begin_quote
GNU Emacs [is] a sort of hybrid between Windows Notepad, a monolithic-kernel operating system, and the International Space Station.

---Steve Yegge
#+end_quote
#+end_aside
Vim, the program I had been using for easy LaTeX input, has had a longstanding "rivalry" with another editor called GNU Emacs.
Since spending time with both programs, I've found this "rivalry" a bit silly.
Vim and emacs are different programs designed with different use cases in mind with different philosophies.
They just /happen/ to both be text editors.
Comparing vim and emacs is a bit like comparing a bicycle to a tank simply because they can move people around quicker than by foot.

In any case, what brought me to emacs was org-mode.
Org-mode is a major mode of emacs, encompassing everything from marking up basic text files and exporting to PDF, keeping an agenda, and literally everything else you could imagine needing when it comes to typing documents of any sort.
Many think of it as souped-up markdown, but this is a disservice to its utility.
It's so powerful, I could probably find a way to make it do my laundry[fn:1].

What initially drove me to org-mode was the function =org-latex-preview=.
In contrast to vim, emacs is a graphical program, which allows the program to /display images of compiled LaTeX over the text buffer you're editing./
Let's see what that looks like.

Org-mode is plaintext, so the raw text file you're editing might look something like this.

#+begin_example
**Hermitian Metrics
We'd like an analogue of Riemannian manifolds but "complexified".
Recall that a metric \( g \) is a \( 2\times 2 \) symmetric matrix at a point.
The complex analogue of "symmetric" is Hermitian, which motivates the following definition:

*Definition:* A /Hermitian metric/ on a complex manifold with local coordinates \( (z^1,\ldots , z^m) \) is a tensor field
\begin{equation*}
h_{j \overline{k}} dz^j\otimes dz^{\overline{k}}
\end{equation*}
where \( h_{j \overline{k}} \) varies smoothly, and is positive definite and Hermitian at each point \( z \).
The form
\begin{equation*}
\omega = \frac{i}{2} h_{j \overline{k}} dz^j\wedge dz^{\overline{k}}
\end{equation*}
is called the /Kahler form/ of the metric.
A complex manifold with a Hermitian metric is called a /Hermitian manifold/.
#+end_example

Here is this same snippet of text, but viewed in emacs, with all the org goodies activated.
[[~/Pictures/website/org-latex-goodies-ex.png]]

Notice how the compiled LaTeX appears inline, and the font size is variable for the heading.
These inline LaTeX previews are what pulled me to org-mode, and with the help of some third party programs like =xenops-mode=[fn:2], these previews render asynchronously as I continue typing.

There are many moving parts to this puzzle, but videos speak louder than words, so here is a quick demo.
#+caption: Sped up 30%
[[~/Videos/emacs-math-demo.gif]]

I could write more about how I achieved this setup, but others that are much smarter than me already have.


[fn:1] My [[*My DOOM Emacs Configuration][DOOM Emacs Config]] is typed in org-mode thanks to its literate programming abilities. In fact, this entire website is just one big org-mode file.

[fn:2] With org version 9.7, =xenops-mode= will be wholly unnecessary thanks to a new default =org-latex-preview= function. See a demo [[https://www.youtube.com/watch?v=n-AfvuV-bYo&t=376s][here]].

** My DOOM Emacs Configuration :emacs:org:hobby:
:PROPERTIES:
:EXPORT_HUGO_SECTION: computing
:EXPORT_FILE_NAME: doom-config
:END:
#+attr_html: :class toc-class
#+begin_details
#+begin_summary
*Table of Contents*
#+end_summary
#+toc: headlines 2 local
#+end_details
#+include: ~/.doom.d/config.org
* Misc
:PROPERTIES:
:EXPORT_HUGO_SECTION: misc
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :type post
:END:
** Misc
:PROPERTIES:
:EXPORT_HUGO_SECTION: misc
:EXPORT_FILE_NAME: _index
:EXPORT_HUGO_MENU: :menu main
:END:
Some stuff that doesn't really fit anywhere else.
** DRAFT Managing Factor Tilts with the Portfolio Performance Program
*** Rebalancing
When maintaining a desired asset allocation in an investment portfolio, [[https://www.investopedia.com/terms/r/rebalancing.asp][rebalancing]] plays an important role.
Rebalancing is necessary to main a targeted asset allocation because different investment instruments perform differently over short periods of time.
Let's take a sample portfolio of $100 of two uncorrelated assets: equity and intermediate-term US treasuries.

Over the course of a year, our equity position might return 10%, while our bond position might only return 3%.
If we initially had our portfolio in  80% equity and 20% bonds, we would have \( \$80 \times 1.10= \$88 \) at the end of the year, and \( \$ 30\times 1.03= \$ 20.6 \) in bonds (assuming we reinvest distributions).
Our total portfolio value is now $108.6, but now our equity position makes up 81% of our portfolio, while bonds make up only ~19% of the portfolio.
This phenomenon is known as "drift".

If left unchecked, consistent differences in asset performance will cause drift to magnify, causing our portfolio to be more and more dominated by the higher-performing asset.
But we chose the 80/20 allocation on the basis of risk profile, and a drifting asset allocation alters the risk profile of the assets owned.
*Rebalancing* is the act of correcting the drift, and can accomplished by a mixture of two strategies: selling enough of the outperforming assets and reinvesting in the

** Astrophotos :astro:hobby:
:PROPERTIES:
:EXPORT_HUGO_SECTION: misc
:EXPORT_FILE_NAME: astrophotos
:END:
As a fairly new astrophotographer, these images will be quite poor to the discerning eye. Artifacts like dust spots, field curvature, and star trails can be seen in pretty much all of them, among many more artifacts. Regardless, I find a lot of satisfaction in this hobby as a fascinating blend of science and art.
*** M101: Pinwheel Galaxy
#+name: m101
#+caption: M101, The Pinwheel Galaxy
[[file:~/Pictures/astro/m101_take2.jpg][file:~/Pictures/astro/m101_take2.jpg]]
#+begin_details
#+begin_summary
Details
#+end_summary

It's been a while since I took this image, but I belive it total around 3 hours of integration
#+end_details
*** M42: The Orion Nebula
#+name: m42
#+caption: M42, The Orion Nebula
[[file:~/Pictures/astro/orion_phone_wallpaper.jpg][file:~/Pictures/astro/orion_phone_wallpaper.jpg]]
#+begin_details
#+begin_summary
Details
#+end_summary
This image was processed from my first ever outing doing astrophotography. It totals around 12 minutes of integration from the Bortle 1 sky around the McDonald Observatory. Weather prevented any more data collection, but I'm still surprised at how much I was able to get out of it. By contrast my [[*M101: Pinwheel Galaxy][image of M101]] was taken from a very light-polluted Bortle 8 sky, and that image was 3 hours of integration. This image always surprises me at how much better it is to image under dark skies.

The uneven illumination on the bottom left of the image is due to a strange reflection pattern on an IR cut filter I have for my camera. It's not present in other images because I imaged those without the filter.
#+end_details
** Some Theorems
:PROPERTIES:
:EXPORT_HUGO_SECTION: misc
:EXPORT_FILE_NAME: fav_theorems
:END:

#+begin_details
#+begin_summary
Table of Contents
#+end_summary
#+toc: headlines 1
#+end_details

*** Modular categories are not determined by their modular data
#+begin_details
#+begin_summary
A modular category \( \mathcal{C} \) is not determined by its \( S \) and \( T \) matrices.
#+end_summary

*Comments:* If something seems too good to be true, it probably is.
#+end_details
*** Classification of commutative Frobenius algebras by TQFTs
#+begin_details
#+begin_summary
For a field \( k \), there is an equivalence of categories \( \mathsf{2TQFT}_k \simeq \mathsf{cFrob}_k \) of 2-dimensional topological quantum field theories and commutative Frobenius algebras.
#+end_summary

*Comments:* This was the first result I learned that expressed how some classical tensor algebras arise as categorical constructions. Essential to this equivalence is the classification of closed 1-dimensional manifolds and how well behaved the category \( \mathsf{2Cob} \) is. A significant amount of work is needed to even hypothesize a higher dimensional analogue. This is the cobordism hypothesis, proposed by Baez and Dolan.
#+end_details
*** The Yoneda Lemma
#+begin_details
#+begin_summary
Let \( \mathsf{C} \) be a locally small category and \( F : \mathsf{C} \to \mathsf{Set} \) be a functor. Then
\[
\operatorname*{Hom}(\operatorname*{Hom}(X,-),F) \cong FX
\]
and this isomorphism is natural in both \(X\) and \(F\).
#+end_summary

*Comments:* This theorem is remarkable. The object on the left, as a collection of natural transformations, is seemingly incalculably large. Not only does this theorem tell us that this collection is a set, but it also gives an *explicit description* of these transformations, parameterized by \( FX \). When applied to \( F = \operatorname*{Hom}(Y,-) \) (or more generally representable functors), this theorem gives meaning to the intuitively-known idea that an object is uniquely determined by the maps into (our out of) it.
#+end_details
* 日本語コーナー
:PROPERTIES:
:EXPORT_HUGO_SECTION: nihongo
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :type post
:END:
** 日本語コーナー
:PROPERTIES:
:EXPORT_HUGO_SECTION: nihongo
:EXPORT_HUGO_MENU: :menu main
:EXPORT_FILE_NAME: _index
:END:

ここで日本語に関して勉強したり読んだりするものを話す。

** 「氷が効かなくなってきている」
:PROPERTIES:
:EXPORT_HUGO_SECTION: nihongo
:EXPORT_FILE_NAME: jojos_interesting_phrase
:END:
I came across the phrase「氷が行かなくなってきている」in an episode of Jojo's Bizarre Adventure and couldn't help but smile at it.
The morphology of Japanese words is a fascinating one, and this sentence exemplifies it brilliantly.
Roughly, this sentence says "the ice is becoming ineffective", or more naturally, "the ice is becoming less effective".
The first word 「氷」, is straightforward; it means "ice".
The particle 「が」 is an indicative particle meant to direct the attention of the listener to the noun it is attached to.

Now here comes the interesting part: the final 「効かなくなってきている」.
The base of this phrase is 「効く」, which means "to be effective, to function, to work".
From here, the verb is morphed to its negative 「効かない」.
Of course, this means "to not be effective".
One cool things about Japanese is that most words that end in 「い」morph like 「ーい」adjectives.
One such way 「ーい」adjective morph is by replacing the い with く.
This morph is typically described as turning the adjective into an adverb, but the idea of turning a negative-conjugated verb into an adverb is a bit mysterious, especially since no such pattern exists in english.
Now we're left with 「効かなく」.

Now that we have an "adverb", we need a verb for it to describe.
This is where 「なる」comes in.
The entire last part 「なってきている」is a morph of this verb, which means "to become".
「なる」 becomes 「なって」, which is a special morph (called -te form) of verbs that can set up a number of new morphs.
From here we add the verb 「来る」, which means "to come to be".
From 「なって来る」 we then turn the 「来る」 into /its/ -te form, yielding 「なってきて」.
(It's worth nothing that this construction is usually written in kana, hence I drop the kanji.)
The final addition is the verb 「いる」.
When this verb is added to the -te form of another verb, it expresses an enduring state of action.
Oftentimes this translated to the present progressive form in english, e.g. run -> /running/.

So we're left with 「なってきている」, which roughly means "is becoming".
The nuance of the 「きて」 is sadly lost since there is no real way to directly translate this to english.

When I first heard this sentence it took me some seconds to parse.
As an english native speaker, I'm not used to having to listen this long to a single phrase to glean its meaning.
Let's take a different approach to illustrate how long words can be constructed.

Remember the 「ーい」 adjective morphs I mentioned?
It turns out that the negative of an 「ーい」 adjective is also an 「ーい」 adjective!
As such, there is theoretically *no upper bound to how long of a "word" you can grammatically correctly construct in Japanese*.

The construction is simple: take an 「ーい」 adjective and negate it.
The way to do this is change the final 「い」 to 「くない」.
Repeat.
For example with the word 「よい」, meaning "good", we can negate it twice to the word meaning "not not good":
#+begin_example
よい ー> よくない ー> よくなくない
#+end_example
But the final word here is also an 「ーい」 adjective.
This means that this is also a grammatically correct construction:
#+begin_example
よくなくなくなくなくなくなくなくなくなくなくなくなくない
#+end_example
Repeat as needed to construct as long of a word as you want.
Of course, we've long left the issue of pragmatism behind, but still, it's pretty not not not not not not not not not not not not not not not not cool, huh?

